(function(global,factory){typeof exports==='object'&&typeof module!=='undefined'?module.exports=factory():typeof define==='function'&&define.amd?define(factory):(global=global||self,global['florence-datacontainer']=factory())}(this,(function(){'use strict';var _a;var hasSymbol=typeof Symbol!=="undefined";var hasMap=typeof Map!=="undefined";var hasSet=typeof Set!=="undefined";var NOTHING=hasSymbol?Symbol("immer-nothing"):(_a={},_a["immer-nothing"]=true,_a);var DRAFTABLE=hasSymbol?Symbol("immer-draftable"):"__$immer_draftable";var DRAFT_STATE=hasSymbol?Symbol("immer-state"):"__$immer_state";var iteratorSymbol=hasSymbol?Symbol.iterator:"@@iterator";var extendStatics=function(d,b){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p]}}};return extendStatics(d,b)};function __extends(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=(__.prototype=b.prototype,new __())}var Archtype;(function(Archtype){Archtype[Archtype["Object"]=0]="Object";Archtype[Archtype["Array"]=1]="Array";Archtype[Archtype["Map"]=2]="Map";Archtype[Archtype["Set"]=3]="Set"})(Archtype||(Archtype={}));var ProxyType;(function(ProxyType){ProxyType[ProxyType["ProxyObject"]=0]="ProxyObject";ProxyType[ProxyType["ProxyArray"]=1]="ProxyArray";ProxyType[ProxyType["ES5Object"]=2]="ES5Object";ProxyType[ProxyType["ES5Array"]=3]="ES5Array";ProxyType[ProxyType["Map"]=4]="Map";ProxyType[ProxyType["Set"]=5]="Set"})(ProxyType||(ProxyType={}));function isDraft(value){return!!value&&!!value[DRAFT_STATE]}function isDraftable(value){if(!value){return false}return isPlainObject(value)||Array.isArray(value)||!!value[DRAFTABLE]||!!value.constructor[DRAFTABLE]||isMap(value)||isSet(value)}function isPlainObject(value){if(!value||typeof value!=="object"){return false}var proto=Object.getPrototypeOf(value);return!proto||proto===Object.prototype}var ownKeys=typeof Reflect!=="undefined"&&Reflect.ownKeys?Reflect.ownKeys:typeof Object.getOwnPropertySymbols!=="undefined"?function(obj){return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj))}:Object.getOwnPropertyNames;function each(obj,iter){if(getArchtype(obj)===Archtype.Object){ownKeys(obj).forEach(function(key){return iter(key,obj[key],obj)})}else{obj.forEach(function(entry,index){return iter(index,entry,obj)})}}function isEnumerable(base,prop){var desc=Object.getOwnPropertyDescriptor(base,prop);return desc&&desc.enumerable?true:false}function getArchtype(thing){if(!thing){die()}if(thing[DRAFT_STATE]){switch(thing[DRAFT_STATE].type){case ProxyType.ES5Object:case ProxyType.ProxyObject:return Archtype.Object;case ProxyType.ES5Array:case ProxyType.ProxyArray:return Archtype.Array;case ProxyType.Map:return Archtype.Map;case ProxyType.Set:return Archtype.Set}}return Array.isArray(thing)?Archtype.Array:isMap(thing)?Archtype.Map:isSet(thing)?Archtype.Set:Archtype.Object}function has(thing,prop){return getArchtype(thing)===Archtype.Map?thing.has(prop):Object.prototype.hasOwnProperty.call(thing,prop)}function get(thing,prop){return getArchtype(thing)===Archtype.Map?thing.get(prop):thing[prop]}function set(thing,propOrOldValue,value){switch(getArchtype(thing)){case Archtype.Map:thing.set(propOrOldValue,value);break;case Archtype.Set:thing.delete(propOrOldValue);thing.add(value);break;default:thing[propOrOldValue]=value}}function is(x,y){if(x===y){return x!==0||1/x===1/y}else{return x!==x&&y!==y}}function isMap(target){return hasMap&&target instanceof Map}function isSet(target){return hasSet&&target instanceof Set}function latest(state){return state.copy||state.base}function shallowCopy(base,invokeGetters){if(invokeGetters===void 0){invokeGetters=false}if(Array.isArray(base)){return base.slice()}var clone=Object.create(Object.getPrototypeOf(base));ownKeys(base).forEach(function(key){if(key===DRAFT_STATE){return;}var desc=Object.getOwnPropertyDescriptor(base,key);var value=desc.value;if(desc.get){if(!invokeGetters){throw new Error("Immer drafts cannot have computed properties")}value=desc.get.call(base)}if(desc.enumerable){clone[key]=value}else{Object.defineProperty(clone,key,{value:value,writable:true,configurable:true})}});return clone}function freeze(obj,deep){if(!isDraftable(obj)||isDraft(obj)||Object.isFrozen(obj)){return}var type=getArchtype(obj);if(type===Archtype.Set){obj.add=obj.clear=obj.delete=dontMutateFrozenCollections}else if(type===Archtype.Map){obj.set=obj.clear=obj.delete=dontMutateFrozenCollections}Object.freeze(obj);if(deep){each(obj,function(_,value){return freeze(value,true)})}}function dontMutateFrozenCollections(){throw new Error("This object has been frozen and should not be mutated")}function createHiddenProperty(target,prop,value){Object.defineProperty(target,prop,{value:value,enumerable:false,writable:true})}function die(){throw new Error("Illegal state, please file a bug")}var ImmerScope=function(){function ImmerScope(parent,immer){this.drafts=[];this.parent=parent;this.immer=immer;this.canAutoFreeze=true}ImmerScope.prototype.usePatches=function(patchListener){if(patchListener){this.patches=[];this.inversePatches=[];this.patchListener=patchListener}};ImmerScope.prototype.revoke=function(){this.leave();this.drafts.forEach(revoke);this.drafts=null};ImmerScope.prototype.leave=function(){if(this===ImmerScope.current){ImmerScope.current=this.parent}};ImmerScope.enter=function(immer){var scope=new ImmerScope(ImmerScope.current,immer);ImmerScope.current=scope;return scope};return ImmerScope}();function revoke(draft){var state=draft[DRAFT_STATE];if(state.type===ProxyType.ProxyObject||state.type===ProxyType.ProxyArray){state.revoke()}else{state.revoked=true}}function processResult(immer,result,scope){var baseDraft=scope.drafts[0];var isReplaced=result!==undefined&&result!==baseDraft;immer.willFinalize(scope,result,isReplaced);if(isReplaced){if(baseDraft[DRAFT_STATE].modified){scope.revoke();throw new Error("An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.");}if(isDraftable(result)){result=finalize(immer,result,scope);if(!scope.parent){maybeFreeze(immer,result)}}if(scope.patches){scope.patches.push({op:"replace",path:[],value:result});scope.inversePatches.push({op:"replace",path:[],value:baseDraft[DRAFT_STATE].base})}}else{result=finalize(immer,baseDraft,scope,[])}scope.revoke();if(scope.patches){scope.patchListener(scope.patches,scope.inversePatches)}return result!==NOTHING?result:undefined}function finalize(immer,draft,scope,path){var state=draft[DRAFT_STATE];if(!state){if(Object.isFrozen(draft)){return draft}return finalizeTree(immer,draft,scope)}if(state.scope!==scope){return draft}if(!state.modified){maybeFreeze(immer,state.base,true);return state.base}if(!state.finalized){state.finalized=true;finalizeTree(immer,state.draft,scope,path);if(immer.onDelete&&state.type!==ProxyType.Set){if(immer.useProxies){var assigned=state.assigned;each(assigned,function(prop,exists){if(!exists){immer.onDelete(state,prop)}})}else{var base=state.base,copy_1=state.copy;each(base,function(prop){if(!has(copy_1,prop)){immer.onDelete(state,prop)}})}}if(immer.onCopy){immer.onCopy(state)}if(immer.autoFreeze&&scope.canAutoFreeze){freeze(state.copy,false)}if(path&&scope.patches){generatePatches(state,path,scope.patches,scope.inversePatches)}}return state.copy}function finalizeTree(immer,root,scope,rootPath){var state=root[DRAFT_STATE];if(state){if(state.type===ProxyType.ES5Object||state.type===ProxyType.ES5Array){state.copy=shallowCopy(state.draft,true)}root=state.copy}each(root,function(key,value){return finalizeProperty(immer,scope,root,state,root,key,value,rootPath)});return root}function finalizeProperty(immer,scope,root,rootState,parentValue,prop,childValue,rootPath){if(childValue===parentValue){throw Error("Immer forbids circular references")}var isDraftProp=!!rootState&&parentValue===root;var isSetMember=isSet(parentValue);if(isDraft(childValue)){var path=rootPath&&isDraftProp&&!isSetMember&&!has(rootState.assigned,prop)?rootPath.concat(prop):undefined;childValue=finalize(immer,childValue,scope,path);set(parentValue,prop,childValue);if(isDraft(childValue)){scope.canAutoFreeze=false }}else if(isDraftProp&&is(childValue,get(rootState.base,prop))){return}else if(isDraftable(childValue)){each(childValue,function(key,grandChild){return finalizeProperty(immer,scope,root,rootState,childValue,key,grandChild,rootPath)});if(!scope.parent){maybeFreeze(immer,childValue)}}if(isDraftProp&&immer.onAssign&&!isSetMember){immer.onAssign(rootState,prop,childValue)}}function maybeFreeze(immer,value,deep){if(deep===void 0){deep=false}if(immer.autoFreeze&&!isDraft(value)){freeze(value,deep)}}function createProxy(base,parent){var isArray=Array.isArray(base);var state={type:isArray?ProxyType.ProxyArray:ProxyType.ProxyObject,scope:parent?parent.scope:ImmerScope.current,modified:false,finalized:false,assigned:{},parent:parent,base:base,draft:null,drafts:{},copy:null,revoke:null,isManual:false};var target=state;var traps=objectTraps;if(isArray){target=[state];traps=arrayTraps}var _a=Proxy.revocable(target,traps),revoke=_a.revoke,proxy=_a.proxy;state.draft=proxy;state.revoke=revoke;return proxy}var objectTraps={get:function(state,prop){if(prop===DRAFT_STATE){return state}var drafts=state.drafts;if(!state.modified&&has(drafts,prop)){return drafts[prop]}var value=latest(state)[prop];if(state.finalized||!isDraftable(value)){return value}if(state.modified){if(value!==peek(state.base,prop)){return value}drafts=state.copy}return drafts[prop]=state.scope.immer.createProxy(value,state)},has:function(state,prop){return prop in latest(state)},ownKeys:function(state){return Reflect.ownKeys(latest(state))},set:function(state,prop,value){if(!state.modified){var baseValue=peek(state.base,prop);var isUnchanged=value?is(baseValue,value)||value===state.drafts[prop]:is(baseValue,value)&&prop in state.base;if(isUnchanged){return true}prepareCopy(state);markChanged(state)}state.assigned[prop]=true;state.copy[prop]=value;return true},deleteProperty:function(state,prop){if(peek(state.base,prop)!==undefined||prop in state.base){state.assigned[prop]=false;prepareCopy(state);markChanged(state)}else if(state.assigned[prop]){delete state.assigned[prop]}if(state.copy){delete state.copy[prop]}return true},getOwnPropertyDescriptor:function(state,prop){var owner=latest(state);var desc=Reflect.getOwnPropertyDescriptor(owner,prop);if(desc){desc.writable=true;desc.configurable=state.type!==ProxyType.ProxyArray||prop!=="length"}return desc},defineProperty:function(){throw new Error("Object.defineProperty() cannot be used on an Immer draft");},getPrototypeOf:function(state){return Object.getPrototypeOf(state.base)},setPrototypeOf:function(){throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft");}};var arrayTraps={};each(objectTraps,function(key,fn){arrayTraps[key]=function(){arguments[0]=arguments[0][0];return fn.apply(this,arguments)}});arrayTraps.deleteProperty=function(state,prop){if(isNaN(parseInt(prop))){throw new Error("Immer only supports deleting array indices");}return objectTraps.deleteProperty.call(this,state[0],prop)};arrayTraps.set=function(state,prop,value){if(prop!=="length"&&isNaN(parseInt(prop))){throw new Error("Immer only supports setting array indices and the 'length' property");}return objectTraps.set.call(this,state[0],prop,value,state[0])};function peek(draft,prop){var state=draft[DRAFT_STATE];var desc=Reflect.getOwnPropertyDescriptor(state?latest(state):draft,prop);return desc&&desc.value}function markChanged(state){if(!state.modified){state.modified=true;if(state.type===ProxyType.ProxyObject||state.type===ProxyType.ProxyArray){var copy_1=state.copy=shallowCopy(state.base);each(state.drafts,function(key,value){copy_1[key]=value});state.drafts=undefined}if(state.parent){markChanged(state.parent)}}}function prepareCopy(state){if(!state.copy){state.copy=shallowCopy(state.base)}}function willFinalizeES5(scope,result,isReplaced){scope.drafts.forEach(function(draft){draft[DRAFT_STATE].finalizing=true});if(!isReplaced){if(scope.patches){markChangesRecursively(scope.drafts[0])}markChangesSweep(scope.drafts )}else if(isDraft(result)&&result[DRAFT_STATE].scope===scope){markChangesSweep(scope.drafts)}}function createES5Proxy(base,parent){var isArray=Array.isArray(base);var draft=clonePotentialDraft(base);each(draft,function(prop){proxyProperty(draft,prop,isArray||isEnumerable(base,prop))});var state={type:isArray?ProxyType.ES5Array:ProxyType.ES5Object,scope:parent?parent.scope:ImmerScope.current,modified:false,finalizing:false,finalized:false,assigned:{},parent:parent,base:base,draft:draft,copy:null,revoked:false,isManual:false};createHiddenProperty(draft,DRAFT_STATE,state);return draft}function peek$1(draft,prop){var state=draft[DRAFT_STATE];if(state&&!state.finalizing){state.finalizing=true;var value=draft[prop];state.finalizing=false;return value}return draft[prop]}function get$1(state,prop){assertUnrevoked(state);var value=peek$1(latest(state),prop);if(state.finalizing){return value}if(value===peek$1(state.base,prop)&&isDraftable(value)){prepareCopy$1(state);return state.copy[prop]=state.scope.immer.createProxy(value,state)}return value}function set$1(state,prop,value){assertUnrevoked(state);state.assigned[prop]=true;if(!state.modified){if(is(value,peek$1(latest(state),prop))){return}markChangedES5(state);prepareCopy$1(state)}state.copy[prop]=value}function markChangedES5(state){if(!state.modified){state.modified=true;if(state.parent){markChangedES5(state.parent)}}}function prepareCopy$1(state){if(!state.copy){state.copy=clonePotentialDraft(state.base)}}function clonePotentialDraft(base){var state=base&&base[DRAFT_STATE];if(state){state.finalizing=true;var draft=shallowCopy(state.draft,true);state.finalizing=false;return draft}return shallowCopy(base)}var descriptors={};function proxyProperty(draft,prop,enumerable){var desc=descriptors[prop];if(desc){desc.enumerable=enumerable}else{descriptors[prop]=desc={configurable:true,enumerable:enumerable,get:function(){return get$1(this[DRAFT_STATE],prop)},set:function(value){set$1(this[DRAFT_STATE],prop,value)}}}Object.defineProperty(draft,prop,desc)}function assertUnrevoked(state){if(state.revoked===true){throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+JSON.stringify(latest(state)))}}function markChangesSweep(drafts){for(var i=drafts.length-1;i>=0;i-=1){var state=drafts[i][DRAFT_STATE];if(!state.modified){switch(state.type){case ProxyType.ES5Array:if(hasArrayChanges(state)){markChangedES5(state)}break;case ProxyType.ES5Object:if(hasObjectChanges(state)){markChangedES5(state)}break}}}}function markChangesRecursively(object){if(!object||typeof object!=="object"){return}var state=object[DRAFT_STATE];if(!state){return}var base=state.base,draft=state.draft,assigned=state.assigned,type=state.type;if(type===ProxyType.ES5Object){each(draft,function(key){if(key===DRAFT_STATE){return}if(base[key]===undefined&&!has(base,key)){assigned[key]=true;markChangedES5(state)}else if(!assigned[key]){markChangesRecursively(draft[key])}});each(base,function(key){if(draft[key]===undefined&&!has(draft,key)){assigned[key]=false;markChangedES5(state)}})}else if(type===ProxyType.ES5Array){if(hasArrayChanges(state)){markChangedES5(state);assigned.length=true}if(draft.length<base.length){for(var i=draft.length;i<base.length;i+=1){assigned[i]=false}}else{for(var i=base.length;i<draft.length;i+=1){assigned[i]=true}}var min=Math.min(draft.length,base.length);for(var i=0;i<min;i+=1){if(assigned[i]===undefined){markChangesRecursively(draft[i])}}}}function hasObjectChanges(state){var base=state.base,draft=state.draft;var keys=Object.keys(draft);for(var i=keys.length-1;i>=0;i-=1){var key=keys[i];var baseValue=base[key];if(baseValue===undefined&&!has(base,key)){return true}else{var value=draft[key];var state_1=value&&value[DRAFT_STATE];if(state_1?state_1.base!==baseValue:!is(value,baseValue)){return true}}}return keys.length!==Object.keys(base).length}function hasArrayChanges(state){var draft=state.draft;if(draft.length!==state.base.length){return true}var descriptor=Object.getOwnPropertyDescriptor(draft,draft.length-1);if(descriptor&&!descriptor.get){return true}return false}var DraftMap=function(_super){if(!_super){throw new Error("Map is not polyfilled")}__extends(DraftMap,_super);function DraftMap(target,parent){this[DRAFT_STATE]={type:ProxyType.Map,parent:parent,scope:parent?parent.scope:ImmerScope.current,modified:false,finalized:false,copy:undefined,assigned:undefined,base:target,draft:this,isManual:false,revoked:false};return this}var p=DraftMap.prototype;Object.defineProperty(p,"size",{get:function(){return latest(this[DRAFT_STATE]).size},enumerable:true,configurable:true});p.has=function(key){return latest(this[DRAFT_STATE]).has(key)};p.set=function(key,value){var state=this[DRAFT_STATE];assertUnrevoked(state);if(latest(state).get(key)!==value){prepareCopy$2(state);state.scope.immer.markChanged(state);state.assigned.set(key,true);state.copy.set(key,value);state.assigned.set(key,true)}return this};p.delete=function(key){if(!this.has(key)){return false}var state=this[DRAFT_STATE];assertUnrevoked(state);prepareCopy$2(state);state.scope.immer.markChanged(state);state.assigned.set(key,false);state.copy.delete(key);return true};p.clear=function(){var state=this[DRAFT_STATE];assertUnrevoked(state);prepareCopy$2(state);state.scope.immer.markChanged(state);state.assigned=new Map();return state.copy.clear()};p.forEach=function(cb,thisArg){var _this=this;var state=this[DRAFT_STATE];latest(state).forEach(function(_value,key,_map){cb.call(thisArg,_this.get(key),key,_this)})};p.get=function(key){var state=this[DRAFT_STATE];assertUnrevoked(state);var value=latest(state).get(key);if(state.finalized||!isDraftable(value)){return value}if(value!==state.base.get(key)){return value;}var draft=state.scope.immer.createProxy(value,state);prepareCopy$2(state);state.copy.set(key,draft);return draft};p.keys=function(){return latest(this[DRAFT_STATE]).keys()};p.values=function(){var _a;var _this=this;var iterator=this.keys();return _a={},_a[iteratorSymbol]=function(){return _this.values()},_a.next=function(){var r=iterator.next();if(r.done){return r}var value=_this.get(r.value);return{done:false,value:value}},_a};p.entries=function(){var _a;var _this=this;var iterator=this.keys();return _a={},_a[iteratorSymbol]=function(){return _this.entries()},_a.next=function(){var r=iterator.next();if(r.done){return r}var value=_this.get(r.value);return{done:false,value:[r.value,value]}},_a};p[iteratorSymbol]=function(){return this.entries()};return DraftMap}(Map);function proxyMap(target,parent){return new DraftMap(target,parent)}function prepareCopy$2(state){if(!state.copy){state.assigned=new Map();state.copy=new Map(state.base)}}var DraftSet=function(_super){if(!_super){throw new Error("Set is not polyfilled")}__extends(DraftSet,_super);function DraftSet(target,parent){this[DRAFT_STATE]={type:ProxyType.Set,parent:parent,scope:parent?parent.scope:ImmerScope.current,modified:false,finalized:false,copy:undefined,base:target,draft:this,drafts:new Map(),revoked:false,isManual:false};return this}var p=DraftSet.prototype;Object.defineProperty(p,"size",{get:function(){return latest(this[DRAFT_STATE]).size},enumerable:true,configurable:true});p.has=function(value){var state=this[DRAFT_STATE];assertUnrevoked(state);if(!state.copy){return state.base.has(value)}if(state.copy.has(value)){return true}if(state.drafts.has(value)&&state.copy.has(state.drafts.get(value))){return true}return false};p.add=function(value){var state=this[DRAFT_STATE];assertUnrevoked(state);if(state.copy){state.copy.add(value)}else if(!state.base.has(value)){prepareCopy$3(state);state.scope.immer.markChanged(state);state.copy.add(value)}return this};p.delete=function(value){if(!this.has(value)){return false}var state=this[DRAFT_STATE];assertUnrevoked(state);prepareCopy$3(state);state.scope.immer.markChanged(state);return state.copy.delete(value)||(state.drafts.has(value)?state.copy.delete(state.drafts.get(value)):false)};p.clear=function(){var state=this[DRAFT_STATE];assertUnrevoked(state);prepareCopy$3(state);state.scope.immer.markChanged(state);return state.copy.clear()};p.values=function(){var state=this[DRAFT_STATE];assertUnrevoked(state);prepareCopy$3(state);return state.copy.values()};p.entries=function entries(){var state=this[DRAFT_STATE];assertUnrevoked(state);prepareCopy$3(state);return state.copy.entries()};p.keys=function(){return this.values()};p[iteratorSymbol]=function(){return this.values()};p.forEach=function forEach(cb,thisArg){var iterator=this.values();var result=iterator.next();while(!result.done){cb.call(thisArg,result.value,result.value,this);result=iterator.next()}};return DraftSet}(Set);function proxySet(target,parent){return new DraftSet(target,parent)}function prepareCopy$3(state){if(!state.copy){state.copy=new Set();state.base.forEach(function(value){if(isDraftable(value)){var draft=state.scope.immer.createProxy(value,state);state.drafts.set(value,draft);state.copy.add(draft)}else{state.copy.add(value)}})}}function generatePatches(state,basePath,patches,inversePatches){switch(state.type){case ProxyType.ProxyObject:case ProxyType.ES5Object:case ProxyType.Map:return generatePatchesFromAssigned(state,basePath,patches,inversePatches);case ProxyType.ES5Array:case ProxyType.ProxyArray:return generateArrayPatches(state,basePath,patches,inversePatches);case ProxyType.Set:return generateSetPatches(state,basePath,patches,inversePatches)}}function generateArrayPatches(state,basePath,patches,inversePatches){var _a,_b;var base=state.base,assigned=state.assigned,copy=state.copy;if(!copy){die()}if(copy.length<base.length){_a=[copy,base],base=_a[0],copy=_a[1];_b=[inversePatches,patches],patches=_b[0],inversePatches=_b[1]}var delta=copy.length-base.length;var start=0;while(base[start]===copy[start]&&start<base.length){start+=1}var end=base.length;while(end>start&&base[end-1]===copy[end+delta-1]){end-=1}for(var i=start;i<end;i+=1){if(assigned[i]&&copy[i]!==base[i]){var path=basePath.concat([i]);patches.push({op:"replace",path:path,value:copy[i]});inversePatches.push({op:"replace",path:path,value:base[i]})}}var replaceCount=patches.length;for(var i=end+delta-1;i>=end;i-=1){var path=basePath.concat([i]);patches[replaceCount+i-end]={op:"add",path:path,value:copy[i]};inversePatches.push({op:"remove",path:path})}}function generatePatchesFromAssigned(state,basePath,patches,inversePatches){var base=state.base,copy=state.copy;each(state.assigned,function(key,assignedValue){var origValue=get(base,key);var value=get(copy,key);var op=!assignedValue?"remove":has(base,key)?"replace":"add";if(origValue===value&&op==="replace"){return}var path=basePath.concat(key);patches.push(op==="remove"?{op:op,path:path}:{op:op,path:path,value:value});inversePatches.push(op==="add"?{op:"remove",path:path}:op==="remove"?{op:"add",path:path,value:origValue}:{op:"replace",path:path,value:origValue})})}function generateSetPatches(state,basePath,patches,inversePatches){var base=state.base,copy=state.copy;var i=0;base.forEach(function(value){if(!copy.has(value)){var path=basePath.concat([i]);patches.push({op:"remove",path:path,value:value});inversePatches.unshift({op:"add",path:path,value:value})}i+=1});i=0;copy.forEach(function(value){if(!base.has(value)){var path=basePath.concat([i]);patches.push({op:"add",path:path,value:value});inversePatches.unshift({op:"remove",path:path,value:value})}i+=1})}function applyPatches(draft,patches){patches.forEach(function(patch){var path=patch.path,op=patch.op;if(!path.length){die()}var base=draft;for(var i=0;i<path.length-1;i+=1){base=get(base,path[i]);if(!base||typeof base!=="object"){throw new Error("Cannot apply patch, path doesn't resolve: "+path.join("/"))}}var type=getArchtype(base);var value=deepClonePatchValue(patch.value);var key=path[path.length-1];switch(op){case "replace":switch(type){case Archtype.Map:return base.set(key,value);case Archtype.Set:throw new Error('Sets cannot have "replace" patches.');default:return base[key]=value}case "add":switch(type){case Archtype.Array:return base.splice(key,0,value);case Archtype.Map:return base.set(key,value);case Archtype.Set:return base.add(value);default:return base[key]=value}case "remove":switch(type){case Archtype.Array:return base.splice(key,1);case Archtype.Map:return base.delete(key);case Archtype.Set:return base.delete(patch.value);default:return delete base[key]}default:throw new Error("Unsupported patch operation: "+op)}});return draft}function deepClonePatchValue(obj){if(!obj||typeof obj!=="object"){return obj}if(Array.isArray(obj)){return obj.map(deepClonePatchValue)}if(isMap(obj)){return new Map(Array.from(obj.entries()).map(function(_a){var k=_a[0],v=_a[1];return[k,deepClonePatchValue(v)]}))}if(isSet(obj)){return new Set(Array.from(obj).map(deepClonePatchValue))}var cloned=Object.create(Object.getPrototypeOf(obj));for(var key in obj){cloned[key]=deepClonePatchValue(obj[key])}return cloned}function __spreadArrays(){for(var s=0,i=0,il=arguments.length;i<il;i+=1){s+=arguments[i].length}for(var r=Array(s),k=0,i=0;i<il;i+=1){for(var a=arguments[i],j=0,jl=a.length;j<jl;j+=1,k+=1){r[k]=a[j]}}return r}function verifyMinified(){}var configDefaults={useProxies:typeof Proxy!=="undefined"&&typeof Proxy.revocable!=="undefined"&&typeof Reflect!=="undefined",autoFreeze:typeof process!=="undefined"?process.env.NODE_ENV!=="production":verifyMinified.name==="verifyMinified",onAssign:null,onDelete:null,onCopy:null};var Immer=function(){function Immer(config){var _this=this;this.useProxies=false;this.autoFreeze=false;each(configDefaults,function(key,value){var _a,_b;_this[key]=(_b=(_a=config)===null||_a===void 0?void 0:_a[key],_b!==null&&_b!==void 0?_b:value)});this.setUseProxies(this.useProxies);this.produce=this.produce.bind(this);this.produceWithPatches=this.produceWithPatches.bind(this)}Immer.prototype.produce=function(base,recipe,patchListener){var _this=this;if(typeof base==="function"&&typeof recipe!=="function"){var defaultBase_1=recipe;recipe=base;var self_1=this;return function curriedProduce(base){var arguments$1=arguments;var _this=this;if(base===void 0){base=defaultBase_1}var args=[];for(var _i=1;_i<arguments.length;_i+=1){args[_i-1]=arguments$1[_i]}return self_1.produce(base,function(draft){return recipe.call.apply(recipe,__spreadArrays([_this,draft],args))});}}{if(typeof recipe!=="function"){throw new Error("The first or second argument to `produce` must be a function")}if(patchListener!==undefined&&typeof patchListener!=="function"){throw new Error("The third argument to `produce` must be a function or undefined")}};var result;if(isDraftable(base)){var scope_1=ImmerScope.enter(this);var proxy=this.createProxy(base,undefined);var hasError=true;try{result=recipe(proxy);hasError=false}finally{if(hasError){scope_1.revoke()}else{scope_1.leave()}}if(typeof Promise!=="undefined"&&result instanceof Promise){return result.then(function(result){scope_1.usePatches(patchListener);return processResult(_this,result,scope_1)},function(error){scope_1.revoke();throw error})}scope_1.usePatches(patchListener);return processResult(this,result,scope_1)}else{result=recipe(base);if(result===NOTHING){return undefined}if(result===undefined){result=base}maybeFreeze(this,result,true);return result}};Immer.prototype.produceWithPatches=function(arg1,arg2,arg3){var _this=this;if(typeof arg1==="function"){return function(state){var arguments$1=arguments;var args=[];for(var _i=1;_i<arguments.length;_i+=1){args[_i-1]=arguments$1[_i]}return _this.produceWithPatches(state,function(draft){return arg1.apply(void 0,__spreadArrays([draft],args))})}}if(arg3){die()}var patches,inversePatches;var nextState=this.produce(arg1,arg2,function(p,ip){patches=p;inversePatches=ip});return[nextState,patches,inversePatches]};Immer.prototype.createDraft=function(base){if(!isDraftable(base)){throw new Error("First argument to `createDraft` must be a plain object, an array, or an immerable object");}var scope=ImmerScope.enter(this);var proxy=this.createProxy(base,undefined);proxy[DRAFT_STATE].isManual=true;scope.leave();return proxy};Immer.prototype.finishDraft=function(draft,patchListener){var state=draft&&draft[DRAFT_STATE];if(!state||!state.isManual){throw new Error("First argument to `finishDraft` must be a draft returned by `createDraft`");}if(state.finalized){throw new Error("The given draft is already finalized");}var scope=state.scope;scope.usePatches(patchListener);return processResult(this,undefined,scope)};Immer.prototype.setAutoFreeze=function(value){this.autoFreeze=value};Immer.prototype.setUseProxies=function(value){this.useProxies=value};Immer.prototype.applyPatches=function(base,patches){var i;for(i=patches.length-1;i>=0;i-=1){var patch=patches[i];if(patch.path.length===0&&patch.op==="replace"){base=patch.value;break}}if(isDraft(base)){return applyPatches(base,patches)}return this.produce(base,function(draft){return applyPatches(draft,patches.slice(i+1))})};Immer.prototype.createProxy=function(value,parent){var draft=isMap(value)?proxyMap(value,parent):isSet(value)?proxySet(value,parent):this.useProxies?createProxy(value,parent):createES5Proxy(value,parent);var scope=parent?parent.scope:ImmerScope.current;scope.drafts.push(draft);return draft};Immer.prototype.willFinalize=function(scope,thing,isReplaced){if(!this.useProxies){willFinalizeES5(scope,thing,isReplaced)}};Immer.prototype.markChanged=function(state){if(this.useProxies){markChanged(state)}else{markChangedES5(state)}};return Immer}();var immer=new Immer();var produce=immer.produce;var produceWithPatches=immer.produceWithPatches.bind(immer);var setAutoFreeze=immer.setAutoFreeze.bind(immer);var setUseProxies=immer.setUseProxies.bind(immer);var applyPatches$1=immer.applyPatches.bind(immer);var createDraft=immer.createDraft.bind(immer);var finishDraft=immer.finishDraft.bind(immer);function isColumnOriented(data){if(data.constructor===Object){const columns=Object.keys(data).map(key=>data[key]);return columns.every(column=>column.constructor===Array)}return false}function isRowOriented(data){if(data.constructor===Array){return data.every(row=>row.constructor===Object)}return false}function isGeoJSON(data){const hasCorrectType=data.type==='FeatureCollection';const hasCorrectFeatures=data.features&&data.features.length>0;return hasCorrectType&&hasCorrectFeatures}function checkFormatColumnData(data){checkFormat(data,{internal:false})}function checkFormatInternal(data){checkFormat(data,{internal:true})}function checkFormat(data,{internal}){let dataLength=null;const columnNameChecker=internal?checkInternalDataColumnName:checkRegularColumnName;for(const columnName in data){columnNameChecker(columnName);const column=data[columnName];dataLength=dataLength||column.length;if(internal===false&&dataLength===0){throw new Error('Invalid data: columns cannot be empty')}if(dataLength!==column.length){throw new Error('Invalid data: columns must be of same length')}}}function checkRegularColumnName(columnName){if(columnName.match(forbiddenChars)){throw new Error(`Invalid column name '${ columnName }': '$' and '/' are not allowed'`)}}const forbiddenChars=/[/$]/;function checkInternalDataColumnName(columnName){if(!['$key','$geometry','$grouped'].includes(columnName)){checkRegularColumnName(columnName)}}function adder(){return new Adder}function Adder(){this.reset()}Adder.prototype={constructor:Adder,reset:function(){this.s=this.t=0;},add:function(y){add(temp,y,this.t);add(this,temp.s,this.s);if(this.s){this.t+=temp.t}else{this.s=temp.t}},valueOf:function(){return this.s}};var temp=new Adder;function add(adder,a,b){var x=adder.s=a+b,bv=x-a,av=x-bv;adder.t=(a-av)+(b-bv)}var pi=Math.PI;var tau=pi*2;var abs=Math.abs;var sqrt=Math.sqrt;function noop(){}function streamGeometry(geometry,stream){if(geometry&&streamGeometryType.hasOwnProperty(geometry.type)){streamGeometryType[geometry.type](geometry,stream)}}var streamObjectType={Feature:function(object,stream){streamGeometry(object.geometry,stream)},FeatureCollection:function(object,stream){var features=object.features,i=-1,n=features.length;while(++i<n){streamGeometry(features[i].geometry,stream)}}};var streamGeometryType={Sphere:function(object,stream){stream.sphere()},Point:function(object,stream){object=object.coordinates;stream.point(object[0],object[1],object[2])},MultiPoint:function(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){object=coordinates[i],stream.point(object[0],object[1],object[2])}},LineString:function(object,stream){streamLine(object.coordinates,stream,0)},MultiLineString:function(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){streamLine(coordinates[i],stream,0)}},Polygon:function(object,stream){streamPolygon(object.coordinates,stream)},MultiPolygon:function(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){streamPolygon(coordinates[i],stream)}},GeometryCollection:function(object,stream){var geometries=object.geometries,i=-1,n=geometries.length;while(++i<n){streamGeometry(geometries[i],stream)}}};function streamLine(coordinates,stream,closed){var i=-1,n=coordinates.length-closed,coordinate;stream.lineStart();while(++i<n){coordinate=coordinates[i],stream.point(coordinate[0],coordinate[1],coordinate[2])}stream.lineEnd()}function streamPolygon(coordinates,stream){var i=-1,n=coordinates.length;stream.polygonStart();while(++i<n){streamLine(coordinates[i],stream,1)}stream.polygonEnd()}function geoStream(object,stream){if(object&&streamObjectType.hasOwnProperty(object.type)){streamObjectType[object.type](object,stream)}else{streamGeometry(object,stream)}}function identity(x){return x}var areaSum=adder(),areaRingSum=adder(),x00,y00,x0,y0;var areaStream={point:noop,lineStart:noop,lineEnd:noop,polygonStart:function(){areaStream.lineStart=areaRingStart;areaStream.lineEnd=areaRingEnd},polygonEnd:function(){areaStream.lineStart=areaStream.lineEnd=areaStream.point=noop;areaSum.add(abs(areaRingSum));areaRingSum.reset()},result:function(){var area=areaSum/2;areaSum.reset();return area}};function areaRingStart(){areaStream.point=areaPointFirst}function areaPointFirst(x,y){areaStream.point=areaPoint;x00=x0=x,y00=y0=y}function areaPoint(x,y){areaRingSum.add(y0*x-x0*y);x0=x,y0=y}function areaRingEnd(){areaPoint(x00,y00)}var x0$1=Infinity,y0$1=x0$1,x1= -x0$1,y1=x1;var boundsStream={point:boundsPoint,lineStart:noop,lineEnd:noop,polygonStart:noop,polygonEnd:noop,result:function(){var bounds=[[x0$1,y0$1],[x1,y1]];x1=y1= -(y0$1=x0$1=Infinity);return bounds}};function boundsPoint(x,y){if(x<x0$1){x0$1=x}if(x>x1){x1=x}if(y<y0$1){y0$1=y}if(y>y1){y1=y}}var X0=0,Y0=0,Z0=0,X1=0,Y1=0,Z1=0,X2=0,Y2=0,Z2=0,x00$1,y00$1,x0$2,y0$2;var centroidStream={point:centroidPoint,lineStart:centroidLineStart,lineEnd:centroidLineEnd,polygonStart:function(){centroidStream.lineStart=centroidRingStart;centroidStream.lineEnd=centroidRingEnd},polygonEnd:function(){centroidStream.point=centroidPoint;centroidStream.lineStart=centroidLineStart;centroidStream.lineEnd=centroidLineEnd},result:function(){var centroid=Z2?[X2/Z2,Y2/Z2]:Z1?[X1/Z1,Y1/Z1]:Z0?[X0/Z0,Y0/Z0]:[NaN,NaN];X0=Y0=Z0=X1=Y1=Z1=X2=Y2=Z2=0;return centroid}};function centroidPoint(x,y){X0+=x;Y0+=y;Z0+=1}function centroidLineStart(){centroidStream.point=centroidPointFirstLine}function centroidPointFirstLine(x,y){centroidStream.point=centroidPointLine;centroidPoint(x0$2=x,y0$2=y)}function centroidPointLine(x,y){var dx=x-x0$2,dy=y-y0$2,z=sqrt(dx*dx+dy*dy);X1+=z*(x0$2+x)/2;Y1+=z*(y0$2+y)/2;Z1+=z;centroidPoint(x0$2=x,y0$2=y)}function centroidLineEnd(){centroidStream.point=centroidPoint}function centroidRingStart(){centroidStream.point=centroidPointFirstRing}function centroidRingEnd(){centroidPointRing(x00$1,y00$1)}function centroidPointFirstRing(x,y){centroidStream.point=centroidPointRing;centroidPoint(x00$1=x0$2=x,y00$1=y0$2=y)}function centroidPointRing(x,y){var dx=x-x0$2,dy=y-y0$2,z=sqrt(dx*dx+dy*dy);X1+=z*(x0$2+x)/2;Y1+=z*(y0$2+y)/2;Z1+=z;z=y0$2*x-x0$2*y;X2+=z*(x0$2+x);Y2+=z*(y0$2+y);Z2+=z*3;centroidPoint(x0$2=x,y0$2=y)}function PathContext(context){this._context=context}PathContext.prototype={_radius:4.5,pointRadius:function(_){return this._radius=_,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){if(this._line===0){this._context.closePath()}this._point=NaN},point:function(x,y){switch(this._point){case 0:{this._context.moveTo(x,y);this._point=1;break}case 1:{this._context.lineTo(x,y);break}default:{this._context.moveTo(x+this._radius,y);this._context.arc(x,y,this._radius,0,tau);break}}},result:noop};var lengthSum=adder(),lengthRing,x00$2,y00$2,x0$3,y0$3;var lengthStream={point:noop,lineStart:function(){lengthStream.point=lengthPointFirst},lineEnd:function(){if(lengthRing){lengthPoint(x00$2,y00$2)}lengthStream.point=noop},polygonStart:function(){lengthRing=true},polygonEnd:function(){lengthRing=null},result:function(){var length= +lengthSum;lengthSum.reset();return length}};function lengthPointFirst(x,y){lengthStream.point=lengthPoint;x00$2=x0$3=x,y00$2=y0$3=y}function lengthPoint(x,y){x0$3-=x,y0$3-=y;lengthSum.add(sqrt(x0$3*x0$3+y0$3*y0$3));x0$3=x,y0$3=y}function PathString(){this._string=[]}PathString.prototype={_radius:4.5,_circle:circle(4.5),pointRadius:function(_){if((_= +_)!==this._radius){this._radius=_,this._circle=null}return this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){if(this._line===0){this._string.push("Z")}this._point=NaN},point:function(x,y){switch(this._point){case 0:{this._string.push("M",x,",",y);this._point=1;break}case 1:{this._string.push("L",x,",",y);break}default:{if(this._circle==null){this._circle=circle(this._radius)}this._string.push("M",x,",",y,this._circle);break}}},result:function(){if(this._string.length){var result=this._string.join("");this._string=[];return result}else{return null}}};function circle(radius){return "m0,"+radius+"a"+radius+","+radius+" 0 1,1 0,"+-2*radius+"a"+radius+","+radius+" 0 1,1 0,"+2*radius+"z"}function geoPath(projection,context){var pointRadius=4.5,projectionStream,contextStream;function path(object){if(object){if(typeof pointRadius==="function"){contextStream.pointRadius(+pointRadius.apply(this,arguments))}geoStream(object,projectionStream(contextStream))}return contextStream.result()}path.area=function(object){geoStream(object,projectionStream(areaStream));return areaStream.result()};path.measure=function(object){geoStream(object,projectionStream(lengthStream));return lengthStream.result()};path.bounds=function(object){geoStream(object,projectionStream(boundsStream));return boundsStream.result()};path.centroid=function(object){geoStream(object,projectionStream(centroidStream));return centroidStream.result()};path.projection=function(_){return arguments.length?(projectionStream=_==null?(projection=null,identity):(projection=_).stream,path):projection};path.context=function(_){if(!arguments.length){return context}contextStream=_==null?(context=null,new PathString):new PathContext(context=_);if(typeof pointRadius!=="function"){contextStream.pointRadius(pointRadius)}return path};path.pointRadius=function(_){if(!arguments.length){return pointRadius}pointRadius=typeof _==="function"?_:(contextStream.pointRadius(+_),+_);return path};return path.projection(projection).context(context)}function isInvalid(value){if(value===undefined||value===null){return true}if(value.constructor===Number){return!isFinite(value)}return false}function isDefined(value){return value!==undefined}function isUndefined(value){return value===undefined}function calculateBBoxGeometries(geometries){let bbox=[[Infinity,Infinity],[-Infinity,-Infinity]];for(let i=0;i<geometries.length;i+=1){const geometry=geometries[i];if(!isInvalid(geometry)){bbox=updateBBox(bbox,geometry)}}const bboxObj={x:[bbox[0][0],bbox[1][0]],y:[bbox[0][1],bbox[1][1]]};return bboxObj}const path=geoPath();function updateBBox(bbox,geometry){const newBBox=path.bounds(geometry);bbox[0][0]=bbox[0][0]<newBBox[0][0]?bbox[0][0]:newBBox[0][0];bbox[0][1]=bbox[0][1]<newBBox[0][1]?bbox[0][1]:newBBox[0][1];bbox[1][0]=bbox[1][0]>newBBox[1][0]?bbox[1][0]:newBBox[1][0];bbox[1][1]=bbox[1][1]>newBBox[1][1]?bbox[1][1]:newBBox[1][1];return bbox}function warn(message){if(!process){console.warn(message)}if(process&&process.env.NODE_ENV!=='test'){console.warn(message)}}function calculateDomain(column,columnName){if(columnName==='$grouped'){throw new Error(`Cannot calculate domain of column '${ columnName }'.`)}if(column.length===0){return createEmptyDomain(columnName)}const{firstValidValue,nValidValues}=findFirstValidValue(column);if(nValidValues===0){throw new Error(`Cannot calculate domain of column '${ column }'. Column contains only missing values.`)}if(nValidValues>0){ensureValidDataType(firstValidValue);const type=getDataType(firstValidValue);if(columnName==='$geometry'){return calculateBBoxGeometries(column)}if(columnName!=='$geometry'){return calculateNonGeometryColumnDomain(column,columnName,nValidValues,firstValidValue,type)}}}function createEmptyDomain(columnName){if(columnName==='$geometry'){return{x:[],y:[]}}if(columnName!=='$geometry'){return[]}}function findFirstValidValue(column){let firstValidValue;let nValidValues=0;for(let i=0;i<column.length;i+=1){if(!isInvalid(column[i])){nValidValues+=1;firstValidValue=firstValidValue||column[i]}if(nValidValues>1){break}}return{firstValidValue,nValidValues}}function calculateNonGeometryColumnDomain(column,columnName,nValidValues,firstValidValue,type){let domain;const nUniqueValues=calculateNumberOfUniqueValues(column,type);if(columnHasOnlyOneUniqueValue(nValidValues,nUniqueValues)){domain=calculateDomainForColumnWithOneUniqueValue(nValidValues,nUniqueValues,type,firstValidValue,columnName)}else{domain=calculateDomainForRegularColumn(type,column,columnName)}return domain}function calculateNumberOfUniqueValues(col,type){const uniqueVals={};if(['quantitative','categorical'].includes(type)){for(let i=0;i<col.length;i+=1){const val=col[i];if(!isInvalid(val)){uniqueVals[val]=0}}}if(type==='temporal'){for(let i=0;i<col.length;i+=1){const val=col[i];if(!isInvalid(val)){uniqueVals[val.getTime()]=0}}}if(type==='interval'){for(let i=0;i<col.length;i+=1){const val=col[i];if(!isInvalid(val)){const str=JSON.stringify(val);uniqueVals[str]=0}}}return Object.keys(uniqueVals).length}function columnHasOnlyOneUniqueValue(nValidValues,nUniqueValues){return nValidValues===1||nUniqueValues===1}function calculateDomainForColumnWithOneUniqueValue(nValidValues,nUniqueValues,type,firstValidValue,columnName){const domain=createDomainForSingleValue(type,firstValidValue);const warningText=nValidValues===1?'valid':'unique';if(type!=='categorical'){warn(`Column '${ columnName }' contains only 1 ${ warningText } value: ${ firstValidValue }.\n`+`Using domain ${JSON.stringify(domain)}`)}return domain}function calculateDomainForRegularColumn(type,column,columnName){let domain=initDomain(type);for(let i=0;i<column.length;i+=1){const value=column[i];if(!isInvalid(value)){if(getDataType(value)!==type){throw new Error(`Invalid column ${ columnName }: column contains multiple data types`)}domain=updateDomain(domain,value,type)}}return domain}const minUnixTime=new Date(0);const maxUnixTime=new Date('19 January 2038');function initDomain(type){let domain;switch(type){case 'quantitative':{domain=[Infinity,-Infinity];break}case 'categorical':{domain=[];break}case 'temporal':{domain=[maxUnixTime,minUnixTime];break}case 'interval':{domain=[Infinity,-Infinity];break}}return domain}function updateDomain(domain,value,type){if(!['quantitative','categorical','temporal','interval'].includes(type)){throw new Error(`Cannot set domain for column of type '${ type }'`)}if(type==='quantitative'){if(domain[0]>=value){domain[0]=value}if(domain[1]<=value){domain[1]=value}}if(type==='categorical'){if(!domain.includes(value)){domain.push(value)}}if(type==='temporal'){const epoch=value.getTime();if(domain[0].getTime()>=epoch){domain[0]=value}if(domain[1].getTime()<=epoch){domain[1]=value}}if(type==='interval'){domain=updateDomain(domain,value[0],'quantitative');domain=updateDomain(domain,value[1],'quantitative')}return domain}function createDomainForSingleValue(type,value){let domain;if(type==='quantitative'){domain=[value-1,value+1]}if(type==='categorical'){domain=[value]}if(type==='temporal'){domain=[getDay(value,-1),getDay(value,1)]}if(type==='interval'){domain=value.sort((a,b)=>a-b)}return domain}function getDay(date,days){const dateCopy=new Date(date.getTime());return new Date(dateCopy.setDate(dateCopy.getDate()+days))}function getColumnType(column){const{firstValidValue}=findFirstValidValue(column);return getDataType(firstValidValue)}function getDataType(value){if(isInvalid(value)){return undefined}if(value.constructor===Number){return 'quantitative'}if(value.constructor===String){return 'categorical'}if(value.constructor===Date){return 'temporal'}if(isInterval(value)){return 'interval'}if(isGeometry(value)){return 'geometry'}if(value.constructor===DataContainer){return 'grouped'}return undefined}function ensureValidDataType(value){if(isInvalid(getDataType(value))){throw new Error('Invalid data')}}function isGeometry(value){return value.constructor===Object&&'type'in value&&'coordinates'in value}function isInterval(value){return value.constructor===Array&&value.length===2&&value.every(entry=>entry.constructor===Number)}function generateKeyColumn(length){return[length].fill(0).map((_,i)=>i)}function validateKeyColumn(keyColumn,requiredLength){if(keyColumn.length!==requiredLength){throw new Error('Key column must be of same length as rest of the data')}ensureAllSameType(keyColumn);ensureUnique(keyColumn)}function ensureAllSameType(keyColumn){for(let i=0;i<keyColumn.length;i+=1){const key=keyColumn[i];validateKey(key)}}function validateKey(key){const type=getDataType(key);if(type!=='quantitative'||!Number.isInteger(key)){throw new Error('Key column can contain only integers')}}function ensureUnique(keyColumn){if(keyColumn.length!==new Set(keyColumn).size){throw new Error('Keys must be unique')}}function getDataLength(data){const firstKey=Object.keys(data)[0];const firstColumn=data[firstKey];return firstColumn.length}function convertRowToColumnData(data){checkIfDataIsEmpty(data);let columnData=initColumnData(data);for(let row of data){for(let key in row){columnData[key].push(row[key])}}return columnData}function initColumnData(data){let firstRow=data[0];let columnKeys=Object.keys(firstRow);let columnData={};for(let key of columnKeys){columnData[key]=[]}return columnData}function checkIfDataIsEmpty(data){if(data.length===0){throw new Error('Received empty Array while trying to load row-oriented data. This is not allowed.')}}function parseGeoJSON(geojsonData){const geometryData=[];const data={};const features=geojsonData.features;const firstFeature=features[0];if('properties'in firstFeature){for(const columnName in firstFeature.properties){data[columnName]=[]}}for(let i=0;i<features.length;i+=1){const{geometry,properties}=features[i];geometryData.push(geometry);for(const columnName in properties){data[columnName].push(properties[columnName])}}checkFormatColumnData(data);data.$geometry=geometryData;return data}const methods={_setColumnData(data,options){if(options.validate===false){checkFormatInternal(data)}else{checkFormatColumnData(data)}this._storeData(data,options)},_setRowData(rowData,options){const columnData=convertRowToColumnData(rowData);this._setColumnData(columnData,options)},_setGeoJSON(geojsonData,options){const data=parseGeoJSON(geojsonData);this._storeData(data,options)},_setGroup(group,options){const data=group.data;checkFormatInternal(data);this._storeData(data,options)},_storeData(data,options){this._data=data;this._setupKeyColumn();if(options.validate===true){this.validateAllColumns()}},_setupKeyColumn(){const length=getDataLength(this._data);if('$key'in this._data){validateKeyColumn(this._data.$key,length);this._syncKeyToRowNumber()}else{const keyColumn=generateKeyColumn(length);this._setKeyColumn(keyColumn)}},_setKeyColumn(keyColumn){this._data=produce(this._data,draft=>{draft.$key=keyColumn});this._syncKeyToRowNumber()},_syncKeyToRowNumber(){const length=getDataLength(this._data);for(let i=0;i<length;i+=1){const key=this._data.$key[i];this._keyToRowNumber[key]=i}}};function dataLoadingMixin(targetClass){Object.assign(targetClass.prototype,methods)}function filter(data,filterFunction){const length=getDataLength(data);const newData={};for(const colName in data){newData[colName]=[]}for(let i=0;i<length;i+=1){const row={};for(const colName in data){row[colName]=data[colName][i]}if(filterFunction(row,i)===true){for(const colName in row){newData[colName].push(row[colName])}}}return newData}function select(data,selection){if(selection.constructor===String){selection=[selection]}if(selection.constructor===Array){validateSelectionInstructions(data,selection);for(const columnName in data){if(!selection.includes(columnName)){delete data[columnName]}}}else{throw new Error('select can only be used with a string or array of strings')}}function validateSelectionInstructions(data,selection){for(const columnName of selection){if(!(columnName in data)){throw new Error(`Column '${ columnName }' not found`)}}}function arrange(data,sortInstructions){if(sortInstructions.constructor===Object){sort(data,sortInstructions)}else if(sortInstructions.constructor===Array){for(let i=sortInstructions.length-1;i>=0;i-=1){const instruction=sortInstructions[i];sort(data,instruction)}}else{throw new Error('arrange requires a key-value object or array of key-value objects')}}const sortFuncs={quantitative:{ascending:(a,b)=>a<b?-1:a>b?1:a>=b?0:NaN,descending:(a,b)=>b<a?-1:b>a?1:b>=a?0:NaN},categorical:{ascending:(a,b)=>{const sorted=[a,b].sort();return sorted[0]===a?-1:1},descending:(a,b)=>{const sorted=[a,b].sort();return sorted[0]===a?1:-1}},temporal:{ascending:(a,b)=>{return a<b?-1:a>b?1:a>=b?0:NaN},descending:(a,b)=>{return b<a?-1:b>a?1:b>=a?0:NaN}}};function sort(data,sortInstructions){if(Object.keys(sortInstructions).length!==1){throw new Error('Only one key-value pair allowed')}const variable=Object.keys(sortInstructions)[0];const sortMethod=sortInstructions[variable];ensureValidDataType(data[variable][0]);const dataType=getDataType(data[variable][0]);let sortFunc;if(sortMethod.constructor===String){sortFunc=sortFuncs[dataType][sortMethod]}if(sortMethod.constructor===Function){sortFunc=sortMethod}const column=data[variable];const indices=column.map((v,i)=>i);const sortedIndices=indices.sort((a,b)=>sortFunc(column[a],column[b]));for(const colName in data){data[colName]=reorder(data[colName],sortedIndices)}}function reorder(column,indices){return indices.map(i=>column[i])}function rename(data,renameInstructions){if(renameInstructions.constructor!==Object){throw new Error('Rename only accepts an object')}for(const oldName in renameInstructions){if(oldName in data){const newName=renameInstructions[oldName];checkRegularColumnName(newName);data[newName]=data[oldName];delete data[oldName]}else{warn(`Rename: column '${ oldName }' not found`)}}}function mutate(data,mutateInstructions){const length=getDataLength(data);const newData={};for(const key in mutateInstructions){newData[key]=[length]}for(let i=0;i<length;i+=1){const row={};let prevRow={};let nextRow={};for(const colName in data){row[colName]=data[colName][i];prevRow[colName]=data[colName][i-1];nextRow[colName]=data[colName][i+1]}if(i===0){prevRow=undefined}if(i===length-1){nextRow=undefined}for(const key in mutateInstructions){const mutateFunction=mutateInstructions[key];newData[key][i]=mutateFunction(row,i,prevRow,nextRow)}}Object.assign(data,newData)}function transmute(data,mutateObj){data=mutate(data,mutateObj);for(const key in data){if(!(key in mutateObj)){delete data[key]}}}var aggregations={count,sum,mean,median,mode,min,max};function count(column){return column.length}function sum(column){let total=0;for(const value of column){total+=value}return total}function mean(column){return sum(column)/count(column)}function median(column){const asc=column.sort((a,b)=>a>b);const len=count(column);if(len%2===1){return asc[Math.floor(len/2)]}else{const lower=asc[(len/2)-1];const upper=asc[(len/2)];return(lower+upper)/2}}function mode(column){const counts={};for(const value of column){if(value in counts){counts[value]+=1}else{counts[value]=1}}let winner;let winningVal=0;for(const value in counts){if(counts[value]>winningVal){winningVal=counts[value];winner=value}}return winner}function min(column){let winner=Infinity;for(const value of column){if(value<winner){winner=value}}return winner}function max(column){let winner= -Infinity;for(const value of column){if(value>winner){winner=value}}return winner}function checkKeyValuePair(obj,allowedKeys){const keys=Object.keys(obj);if(keys.length!==1){throw new Error('Invalid transformation syntax')}const key=keys[0];if(!allowedKeys.includes(key)){throw new Error(`Unknown transformation ${ key }`)}return key}function summarise(data,summariseInstructions){if(summariseInstructions.constructor!==Object){throw new Error('summarise must be an object')}let newData=initNewData(summariseInstructions,data);if('$grouped'in data){checkSummariseInstructions(summariseInstructions,data);for(const columnName in data){if(columnName!=='$grouped'){newData[columnName]=data[columnName]}}for(const group of data.$grouped){const data=group.data();newData=summariseGroup(data,summariseInstructions,newData)}}else{newData=summariseGroup(data,summariseInstructions,newData)}return newData}function initNewData(summariseInstructions,data){const newData={};for(const newCol in summariseInstructions){newData[newCol]=[]}if(data&&'$grouped'in data){for(const col in data){if(col!=='$grouped'){newData[col]=[]}}}return newData}function summariseGroup(data,summariseInstructions,newData){for(const newColName in summariseInstructions){const instruction=summariseInstructions[newColName];if(instruction.constructor===Object){const column=checkKeyValuePair(instruction,Object.keys(data));const aggregation=instruction[column];if(aggregation.constructor===String){if(!(aggregation in aggregations)){throw new Error(`Unkown summaryMethod: '${ aggregation }'.`)}newData[newColName].push(aggregations[aggregation](data[column]))}else if(aggregation.constructor===Function){newData[newColName].push(aggregation(data[column]))}else{throw new Error(`Invalid summaryMethod: '${ aggregation }'. Must be String or Function`)}}}return newData}function checkSummariseInstructions(summariseInstructions,data){for(const newColName in summariseInstructions){const instruction=summariseInstructions[newColName];const name=Object.keys(instruction)[0];checkRegularColumnName(name);if(name in data){throw new Error(`Cannot summarise the column '${ name }': used for grouping`)}}}function mutarise(data,mutariseInstructions){if(mutariseInstructions.constructor!==Object){throw new Error('mutarise must be an object')}let newCols=initNewData(mutariseInstructions);if('$grouped'in data){checkSummariseInstructions(mutariseInstructions,data);for(const group of data.$grouped){let summarizedData=initNewData(mutariseInstructions);const dataInGroup=group.data();summarizedData=summariseGroup(dataInGroup,mutariseInstructions,summarizedData);const length=getDataLength(dataInGroup);newCols=addGroupSummaries(newCols,summarizedData,length)}data=ungroup(data)}else{let summarizedData=initNewData(mutariseInstructions);summarizedData=summariseGroup(data,mutariseInstructions,summarizedData);const length=getDataLength(data);newCols=addGroupSummaries(newCols,summarizedData,length)}return join(data,newCols)}function addGroupSummaries(newCols,summarizedData,length){for(let i=0;i<length;i+=1){for(const key in summarizedData){newCols[key].push(summarizedData[key][0])}}return newCols}function ungroup(data){const newData=initNewData(data.$grouped[0].data());for(const group of data.$grouped){const groupData=group.data();for(const col in newData){newData[col].push(...groupData[col])}}return newData}function join(data,newCols){for(const col in newCols){data[col]=newCols[col]}return data}function groupBy(data,groupByInstructions){const groupedData={};const groupedColumns=getGroupedColumns(data,groupByInstructions);const groups=groupBy$1(data,groupedColumns);groupedData.$grouped=groups.map(group=>new DataContainer(group));for(const col of groupedColumns){groupedData[col]=[]}for(let i=0;i<groupedColumns.length;i+=1){const col=groupedColumns[i];for(const group of groups){groupedData[col].push(group.groupedValues[i])}}return groupedData}function getGroupedColumns(data,groupByInstructions){const con=groupByInstructions.constructor;if(![String,Array].includes(con)){throw new Error('groupBy can only be used with a string or array of strings')}const groupedColumns=con===String?[groupByInstructions]:groupByInstructions;for(const col of groupedColumns){if(!(col in data)){throw new Error(`Column '${ col }' not found`)}}if(groupedColumns.length===Object.keys(data).length){throw new Error('Cannot group by all columns')}return groupedColumns}function getGroupedValues(data,i,columns){const groupedValues=[];for(const col of columns){groupedValues.push(data[col][i])}return groupedValues}function groupBy$1(data,groupedColumns){const groups={};const length=getDataLength(data);for(let i=0;i<length;i+=1){const groupedValues=getGroupedValues(data,i,groupedColumns);const groupID=JSON.stringify(groupedValues);groups[groupID]=groups[groupID]||new Group(data,groupedValues);groups[groupID].addRow(data,i)}return Object.keys(groups).map(group=>{return groups[group]})}class Group{constructor(data,groupedValues){this.data={};this.groupedValues=groupedValues;for(const col in data){this.data[col]=[]}}addRow(data,i){for(const col in data){this.data[col].push(data[col][i])}}}var _t=function(str){return str};var isNumber=function(n){return!isNaN(parseFloat(n))&&isFinite(n)};function Geostats(a){this.objectID='';this.separator=' - ';this.legendSeparator=this.separator;this.method='';this.precision=0;this.precisionflag='auto';this.roundlength=2;this.is_uniqueValues=false;this.debug=false;this.silent=false;this.bounds=[];this.ranges=[];this.inner_ranges=null;this.colors=[];this.counter=[];this.stat_sorted=null;this.stat_mean=null;this.stat_median=null;this.stat_sum=null;this.stat_max=null;this.stat_min=null;this.stat_pop=null;this.stat_variance=null;this.stat_stddev=null;this.stat_cov=null;this.log=function(msg,force){if(this.debug===true||force!=null){console.log(this.objectID+'(object id) :: '+msg)}};this.setBounds=function(a){this.log('Setting bounds ('+a.length+') : '+a.join());this.bounds=[];this.bounds=a;};this.setSerie=function(a){this.log('Setting serie ('+a.length+') : '+a.join());this.serie=[];this.serie=a;this.resetStatistics();this.setPrecision()};this.setColors=function(colors){this.log('Setting color ramp ('+colors.length+') : '+colors.join());this.colors=colors};this.doCount=function(){if(this._nodata()){return}var tmp=this.sorted();this.counter=[];for(let i=0;i<this.bounds.length-1;i+=1){this.counter[i]=0}for(let j=0;j<tmp.length;j+=1){var cclass=this.getClass(tmp[j]);this.counter[cclass]+=1}};this.setPrecision=function(decimals){if(typeof decimals!=='undefined'){this.precisionflag='manual';this.precision=decimals}if(this.precisionflag==='auto'){for(var i=0;i<this.serie.length;i+=1){var precision;if(!isNaN((this.serie[i]+''))&&(this.serie[i]+'').toString().indexOf('.')!==-1){precision=(this.serie[i]+'').split('.')[1].length}else{precision=0}if(precision>this.precision){this.precision=precision}}}if(this.precision>20){this.log('this.precision value ('+this.precision+') is greater than max value. Automatic set-up to 20 to prevent "Uncaught RangeError: toFixed()" when calling decimalFormat() method.');this.precision=20}this.log('Calling setPrecision(). Mode : '+this.precisionflag+' - Decimals : '+this.precision);this.serie=this.decimalFormat(this.serie)};this.decimalFormat=function(a){var b=[];for(var i=0;i<a.length;i+=1){if(isNumber(a[i])){b[i]=parseFloat(parseFloat(a[i]).toFixed(this.precision))}else{b[i]=a[i]}}return b};this.setRanges=function(){this.ranges=[];for(let i=0;i<(this.bounds.length-1);i+=1){this.ranges[i]=this.bounds[i]+this.separator+this.bounds[i+1]}};this.min=function(){if(this._nodata()){return}this.stat_min=this.serie[0];for(let i=0;i<this.pop();i+=1){if(this.serie[i]<this.stat_min){this.stat_min=this.serie[i]}}return this.stat_min};this.max=function(){if(this._nodata()){return}this.stat_max=this.serie[0];for(let i=0;i<this.pop();i+=1){if(this.serie[i]>this.stat_max){this.stat_max=this.serie[i]}}return this.stat_max};this.sum=function(){if(this._nodata()){return}if(this.stat_sum===null){this.stat_sum=0;for(let i=0;i<this.pop();i+=1){this.stat_sum+=parseFloat(this.serie[i])}}return this.stat_sum};this.pop=function(){if(this._nodata()){return}if(this.stat_pop===null){this.stat_pop=this.serie.length}return this.stat_pop};this.mean=function(){if(this._nodata()){return}if(this.stat_mean===null){this.stat_mean=parseFloat(this.sum()/this.pop())}return this.stat_mean};this.median=function(){if(this._nodata()){return}if(this.stat_median===null){this.stat_median=0;var tmp=this.sorted();if(tmp.length%2){this.stat_median=parseFloat(tmp[(Math.ceil(tmp.length/2)-1)]);}else{this.stat_median=(parseFloat(tmp[((tmp.length/2)-1)])+parseFloat(tmp[(tmp.length/2)]))/2}}return this.stat_median};this.variance=function(round){round=(typeof round==='undefined');if(this._nodata()){return}if(this.stat_variance===null){var tmp=0;var serieMean=this.mean();for(var i=0;i<this.pop();i+=1){tmp+=Math.pow((this.serie[i]-serieMean),2)}this.stat_variance=tmp/this.pop();if(round===true){this.stat_variance=Math.round(this.stat_variance*Math.pow(10,this.roundlength))/Math.pow(10,this.roundlength)}}return this.stat_variance};this.stddev=function(round){round=(typeof round==='undefined');if(this._nodata()){return}if(this.stat_stddev===null){this.stat_stddev=Math.sqrt(this.variance());if(round===true){this.stat_stddev=Math.round(this.stat_stddev*Math.pow(10,this.roundlength))/Math.pow(10,this.roundlength)}}return this.stat_stddev};this.cov=function(round){round=(typeof round==='undefined');if(this._nodata()){return}if(this.stat_cov===null){this.stat_cov=this.stddev()/this.mean();if(round===true){this.stat_cov=Math.round(this.stat_cov*Math.pow(10,this.roundlength))/Math.pow(10,this.roundlength)}}return this.stat_cov};this.resetStatistics=function(){this.stat_sorted=null;this.stat_mean=null;this.stat_median=null;this.stat_sum=null;this.stat_max=null;this.stat_min=null;this.stat_pop=null;this.stat_variance=null;this.stat_stddev=null;this.stat_cov=null};this._nodata=function(){if(this.serie.length===0){if(this.silent){this.log('[silent mode] Error. You should first enter a serie!',true)}else{throw new TypeError('Error. You should first enter a serie!')}return 1}else{return 0}};this._nbClassInt=function(nbClass){var nbclassTmp=parseInt(nbClass,10);if(isNaN(nbclassTmp)){if(this.silent){this.log("[silent mode] '"+nbclassTmp+"' is not a valid integer. Enable to set class number.",true)}else{throw new TypeError("'"+nbclassTmp+"' is not a valid integer. Enable to set class number.")}}else{return nbclassTmp}};this._hasNegativeValue=function(){for(let i=0;i<this.serie.length;i+=1){if(this.serie[i]<0){return true}}return false};this._hasZeroValue=function(){for(let i=0;i<this.serie.length;i+=1){if(parseFloat(this.serie[i])===0){return true}}return false};this.sorted=function(){if(this.stat_sorted===null){if(this.is_uniqueValues===false){this.stat_sorted=this.serie.sort(function(a,b){return a-b})}else{this.stat_sorted=this.serie.sort(function(a,b){var nameA=a.toString().toLowerCase();var nameB=b.toString().toLowerCase();if(nameA<nameB){return -1}if(nameA>nameB){return 1}return 0})}}return this.stat_sorted};this.setClassManually=function(array){if(this._nodata()){return}if(array[0]!==this.min()||array[array.length-1]!==this.max()){if(this.silent){this.log('[silent mode] '+_t('Given bounds may not be correct! please check your input.\nMin value : '+this.min()+' / Max value : '+this.max()),true)}else{throw new TypeError(_t('Given bounds may not be correct! please check your input.\nMin value : '+this.min()+' / Max value : '+this.max()))}return}this.setBounds(array);this.setRanges();this.method=_t('manual classification')+' ('+(array.length-1)+' '+_t('classes')+')';return this.bounds};this.getClassEqInterval=function(nbClass,forceMin,forceMax){nbClass=this._nbClassInt(nbClass);if(this._nodata()){return}var tmpMin=(typeof forceMin==='undefined')?this.min():forceMin;var tmpMax=(typeof forceMax==='undefined')?this.max():forceMax;var a=[];var val=tmpMin;var interval=(tmpMax-tmpMin)/nbClass;for(let i=0;i<=nbClass;i+=1){a[i]=val;val+=interval}a[nbClass]=tmpMax;this.setBounds(a);this.setRanges();this.method=_t('eq. intervals')+' ('+nbClass+' '+_t('classes')+')';return this.bounds};this.getQuantiles=function(nbClass){nbClass=this._nbClassInt(nbClass);var tmp=this.sorted();var quantiles=[];var step=this.pop()/nbClass;for(var i=1;i<nbClass;i+=1){var qidx=Math.round(i*step+0.49);quantiles.push(tmp[qidx-1]);}return quantiles};this.getClassQuantile=function(nbClass){nbClass=this._nbClassInt(nbClass);if(this._nodata()){return}var tmp=this.sorted();var bounds=this.getQuantiles(nbClass);bounds.unshift(tmp[0]);if(bounds[tmp.length-1]!==tmp[tmp.length-1]){bounds.push(tmp[tmp.length-1])}this.setBounds(bounds);this.setRanges();this.method=_t('quantile')+' ('+nbClass+' '+_t('classes')+')';return this.bounds};this.getClassStdDeviation=function(nbClass,matchBounds){nbClass=this._nbClassInt(nbClass);if(this._nodata()){return}var tmpMax=this.max();var tmpMin=this.min();var tmpStdDev=this.stddev();var tmpMean=this.mean();var a=[];if(nbClass%2===1){var infBound=Math.floor(nbClass/2);var supBound=infBound+1;a[infBound]=tmpMean-(tmpStdDev/2);a[supBound]=tmpMean+(tmpStdDev/2);for(let i=infBound-1;i>0;i-=1){let val=a[i+1]-tmpStdDev;a[i]=val}for(let i=supBound+1;i<nbClass;i+=1){let val=a[i-1]+tmpStdDev;a[i]=val}}else{var meanBound=nbClass/2;a[meanBound]=tmpMean;for(let i=meanBound-1;i>0;i-=1){let val=a[i+1]-tmpStdDev;a[i]=val}for(let i=meanBound+1;i<nbClass;i+=1){let val=a[i-1]+tmpStdDev;a[i]=val}}a[0]=(typeof matchBounds==='undefined')?a[1]-tmpStdDev:tmpMin;a[nbClass]=(typeof matchBounds==='undefined')?a[nbClass-1]+tmpStdDev:tmpMax;this.setBounds(a);this.setRanges();this.method=_t('std deviation')+' ('+nbClass+' '+_t('classes')+')';return this.bounds};this.getClassGeometricProgression=function(nbClass){nbClass=this._nbClassInt(nbClass);if(this._nodata()){return}if(this._hasNegativeValue()||this._hasZeroValue()){if(this.silent){this.log('[silent mode] '+_t('geometric progression can\'t be applied with a serie containing negative or zero values.'),true)}else{throw new TypeError(_t('geometric progression can\'t be applied with a serie containing negative or zero values.'))}return}var a=[];var tmpMin=this.min();var tmpMax=this.max();var logMax=Math.log(tmpMax)/Math.LN10;var logMin=Math.log(tmpMin)/Math.LN10;var interval=(logMax-logMin)/nbClass;for(let i=0;i<nbClass;i+=1){if(i===0){a[i]=logMin}else{a[i]=a[i-1]+interval}}a=a.map(function(x){return Math.pow(10,x)});a.push(this.max());this.setBounds(a);this.setRanges();this.method=_t('geometric progression')+' ('+nbClass+' '+_t('classes')+')';return this.bounds};this.getClassArithmeticProgression=function(nbClass){nbClass=this._nbClassInt(nbClass);if(this._nodata()){return}var denominator=0;for(let i=1;i<=nbClass;i+=1){denominator+=i}var a=[];var tmpMin=this.min();var tmpMax=this.max();var interval=(tmpMax-tmpMin)/denominator;for(let i=0;i<=nbClass;i+=1){if(i===0){a[i]=tmpMin}else{a[i]=a[i-1]+(i*interval)}}this.setBounds(a);this.setRanges();this.method=_t('arithmetic progression')+' ('+nbClass+' '+_t('classes')+')';return this.bounds};this.getClassJenks=function(nbClass){nbClass=this._nbClassInt(nbClass);if(this._nodata()){return}let dataList=this.sorted();var mat1=[];for(var x=0;x<dataList.length+1;x+=1){var temp=[];for(var j=0,jl=nbClass+1;j<jl;j+=1){temp.push(0)}mat1.push(temp)}var mat2=[];for(var i=0;i<dataList.length+1;i+=1){var temp2=[];for(var c=0,cl=nbClass+1;c<cl;c+=1){temp2.push(0)}mat2.push(temp2)}for(var y=1,yl=nbClass+1;y<yl;y+=1){mat1[0][y]=1;mat2[0][y]=0;for(var t=1,tl=dataList.length+1;t<tl;t+=1){mat2[t][y]=Infinity}var v=0.0}for(var l=2,ll=dataList.length+1;l<ll;l+=1){var s1=0.0;var s2=0.0;var w=0.0;for(var m=1,ml=l+1;m<ml;m+=1){var i3=l-m+1;var val=parseFloat(dataList[i3-1]);s2+=val*val;s1+=val;w+=1;v=s2-(s1*s1)/w;var i4=i3-1;if(i4!==0){for(var p=2,pl=nbClass+1;p<pl;p+=1){if(mat2[l][p]>=(v+mat2[i4][p-1])){mat1[l][p]=i3;mat2[l][p]=v+mat2[i4][p-1]}}}}mat1[l][1]=1;mat2[l][1]=v}var k=dataList.length;var kclass=[];for(i=0;i<=nbClass;i+=1){kclass.push(0)}kclass[nbClass]=parseFloat(dataList[dataList.length-1]);kclass[0]=parseFloat(dataList[0]);var countNum=nbClass;while(countNum>=2){var id=parseInt((mat1[k][countNum])-2);kclass[countNum-1]=dataList[id];k=parseInt((mat1[k][countNum]-1));countNum-=1}if(kclass[0]===kclass[1]){kclass[0]=0}this.setBounds(kclass);this.setRanges();this.method=_t('Jenks')+' ('+nbClass+' '+_t('classes')+')';return this.bounds;};this.getClassUniqueValues=function(){if(this._nodata()){return}this.is_uniqueValues=true;var tmp=this.sorted();var a=[];for(let i=0;i<this.pop();i+=1){if(a.indexOf(tmp[i])===-1){a.push(tmp[i])}}this.bounds=a;this.method=_t('unique values');return a};this.getClass=function(value){for(let i=0;i<this.bounds.length;i+=1){if(this.is_uniqueValues===true){if(value===this.bounds[i]){return i}}else{if(parseFloat(value)<=this.bounds[i+1]){return i}}}return _t("Unable to get value's class.")};this.getRanges=function(){return this.ranges};this.getRangeNum=function(value){var bounds,i;for(i=0;i<this.ranges.length;i+=1){bounds=this.ranges[i].split(/ - /);if(value<=parseFloat(bounds[1])){return i}}};this.getInnerRanges=function(){if(this.inner_ranges!=null){return this.inner_ranges}var a=[];var tmp=this.sorted();var cnt=1;for(let i=0;i<tmp.length;i+=1){let rangeFirstValue;if(i===0){rangeFirstValue=tmp[i];}if(parseFloat(tmp[i])>parseFloat(this.bounds[cnt])){a[cnt-1]=''+rangeFirstValue+this.separator+tmp[i-1];rangeFirstValue=tmp[i];cnt+=1}if(cnt===(this.bounds.length-1)){a[cnt-1]=''+rangeFirstValue+this.separator+tmp[tmp.length-1];this.inner_ranges=a;return this.inner_ranges}}};this.getSortedlist=function(){return this.sorted().join(', ')};this.objectID=new Date().getUTCMilliseconds();this.log('Creating new geostats object');if(typeof a!=='undefined'&&a.length>0){this.serie=a;this.setPrecision();this.log('Setting serie ('+a.length+') : '+a.join())}else{this.serie=[]}this.getJenks=this.getClassJenks;this.getGeometricProgression=this.getClassGeometricProgression;this.getEqInterval=this.getClassEqInterval;this.getQuantile=this.getClassQuantile;this.getStdDeviation=this.getClassStdDeviation;this.getUniqueValues=this.getClassUniqueValues;this.getArithmeticProgression=this.getClassArithmeticProgression}function bin(data,binInstructions){if(binInstructions.constructor===Object){const intervalBounds=getIntervalBounds(data,binInstructions);const ranges=pairRanges(intervalBounds);return bin1d(data,binInstructions.groupBy,ranges)}if(binInstructions.constructor===Array){const intervalBoundsPerVariable=binInstructions.map(instructions=>getIntervalBounds(data,instructions));const rangesPerVariable=intervalBoundsPerVariable.map(bounds=>pairRanges(bounds));const variables=binInstructions.map(instructions=>instructions.groupBy);return binKd(data,variables,rangesPerVariable)}}function getIntervalBounds(data,binInstructions){const{groupBy,method,numClasses}=parseBinInstructions(binInstructions);const variableData=data[groupBy];if(!variableData){throw new Error(`groupBy column '${ groupBy }' does not exist`)}if(method==='IntervalSize'){return createRangesFromBinSize(variableData,binInstructions.binSize)}if(method==='Manual'){return binInstructions.manualClasses}const geoStat=new Geostats(variableData);return geoStat[methodMap[method]](numClasses)}function parseBinInstructions(binInstructions){if(binInstructions.constructor!==Object){throw new Error('Bin only accepts an Object')}const groupBy=binInstructions.groupBy;if(groupBy.constructor!==String){throw new Error('groupBy only accepts a String variable name')}let method=binInstructions.method;if(!method){warn('No binning method specified, defaulting to EqualInterval');method='EqualInterval'}if(method.constructor!==String){warn('Binning method not recognized, defaulting to EqualInterval');method='EqualInterval'}let numClasses=binInstructions.numClasses;if(!numClasses){warn('numClasses not specified, defaulting to 5');numClasses=5}return{groupBy,method,numClasses}}function createRangesFromBinSize(variableData,binSize){if(!binSize){throw new Error('Missing required option \'binSize\'')}const domain=calculateDomain(variableData);const binCount=Math.floor((domain[1]-domain[0])/binSize);let lowerBound=domain[0];const ranges=[lowerBound];for(let i=0;i<binCount-1;i+=1){const upperBound=lowerBound+binSize;ranges.push(upperBound);lowerBound=upperBound}ranges.push(domain[1]);return ranges}const methodMap={EqualInterval:'getClassEqInterval',StandardDeviation:'getClassStdDeviation',ArithmeticProgression:'getClassArithmeticProgression',GeometricProgression:'getClassGeometricProgression',Quantile:'getClassQuantile',Jenks:'getClassJenks'};function pairRanges(ranges){const l=ranges.length;const newRange=[];for(let i=0;i<l-1;i+=1){newRange.push([ranges[i],ranges[i+1]])}return newRange}function bin1d(data,variable,ranges){const groups=Array(ranges.length);for(let i=0;i<groups.length;i+=1){groups[i]={};for(const col in data){groups[i][col]=[]}}const length=getDataLength(data);for(let i=0;i<length;i+=1){const value=data[variable][i];const binIndex=getBinIndex(ranges,value);if(binIndex!==-1){for(const col in data){groups[binIndex][col].push(data[col][i])}}}const nonEmptyBinIndices=getNonEmptyBinIndices(groups);const nonEmptyRanges=nonEmptyBinIndices.map(i=>ranges[i]);const nonEmptyGroups=nonEmptyBinIndices.map(i=>groups[i]);const newData={bins:nonEmptyRanges,$grouped:nonEmptyGroups.map(group=>new DataContainer(group,{validate:false}))};return newData}function getBinIndex(bins,value){const binIndex=bins.findIndex(function(bin,i){if(i===bins.length-1){return value>=bin[0]&&value<=bin[1]}else{return value>=bin[0]&&value<bin[1]}});return binIndex}function getNonEmptyBinIndices(groups){const nonEmptyBinIndices=[];for(let i=0;i<groups.length;i+=1){if(getDataLength(groups[i])>0){nonEmptyBinIndices.push(i)}}return nonEmptyBinIndices}function binKd(data,variables,rangesPerVariable){const binIndexTree=constructBinIndexTree(data,variables,rangesPerVariable);const binnedData=convertTreeIntoColumnData(binIndexTree,variables,rangesPerVariable);binnedData.$grouped=binnedData.$grouped.map(group=>new DataContainer(group,{validate:false}));return binnedData}function constructBinIndexTree(data,variables,rangesPerVariable){let binIndexTree={};const dataLength=getDataLength(data);for(let i=0;i<dataLength;i+=1){const binIndices=getBinIndices(data,i,variables,rangesPerVariable);if(rowIsNotEmpty(binIndices)){binIndexTree=updateBranch(binIndexTree,binIndices,data,i)}}return binIndexTree}function getBinIndices(data,index,variables,rangesPerVariable){const binIndices=[];for(let i=0;i<variables.length;i+=1){const variable=variables[i];const value=data[variable][index];binIndices.push(getBinIndex(rangesPerVariable[i],value))}return binIndices}function rowIsNotEmpty(binIndices){return binIndices.every(binIndex=>binIndex>-1)}function updateBranch(tree,indices,data,rowIndex){let currentLevel=tree;for(let i=0;i<indices.length;i+=1){const index=indices[i];if(lastIndex(i,indices.length)){if(!(index in currentLevel)){currentLevel[index]=initGroup(data)}currentLevel[index]=addRow(currentLevel[index],data,rowIndex)}else{if(!(index in currentLevel)){currentLevel[index]={}}currentLevel=currentLevel[index]}}return tree}function lastIndex(i,length){return i===(length-1)}function initGroup(data){const group={};for(const columnName in data){group[columnName]=[]}return group}function addRow(group,data,rowIndex){for(const columnName in data){group[columnName].push(data[columnName][rowIndex])}return group}function convertTreeIntoColumnData(binIndexTree,variables,binsPerVariable){const columnData=initColumnData$1(variables);const dataIndex=variables.length;forEachBranch(binIndexTree,branchArray=>{for(let i=0;i<variables.length;i+=1){const binIndex=branchArray[i];const bin=binsPerVariable[i][binIndex];const binnedColumnName=getBinnedColumnName(variables[i]);columnData[binnedColumnName].push(bin)}columnData.$grouped.push(branchArray[dataIndex])});return columnData}function initColumnData$1(variables){const columnData={$grouped:[]};for(let i=0;i<variables.length;i+=1){const binnedColumnName=getBinnedColumnName(variables[i]);columnData[binnedColumnName]=[]}return columnData}function forEachBranch(tree,callback){for(const path of traverse(tree)){callback(path)}}function*traverse(o){const memory=new Set();function*innerTraversal(o,path=[]){if(memory.has(o)){return}memory.add(o);for(const i of Object.keys(o)){const itemPath=path.concat(i);if(!('$key'in o[i])){yield*innerTraversal(o[i],itemPath)}else{itemPath.push(o[i]);yield itemPath}}}yield*innerTraversal(o)}function getBinnedColumnName(columnName){return 'bins_'+columnName}function dropNA(data,dropInstructions){let filterFunc;if(!dropInstructions){filterFunc=row=>{let keep=true;for(const key in row){const val=row[key];if(isInvalid(val)){keep=false;break}}return keep}}else if(dropInstructions.constructor===String){checkIfColumnsExist(data,[dropInstructions]);filterFunc=row=>!isInvalid(row[dropInstructions])}else if(dropInstructions.constructor===Array){checkIfColumnsExist(data,dropInstructions);filterFunc=row=>{let keep=true;for(const col of dropInstructions){if(isInvalid(row[col])){keep=false;break}}return keep}}else{throw new Error('dropNA can only be passed undefined, a String or an Array of Strings')}return filter(data,filterFunc)}function checkIfColumnsExist(data,columns){for(const col of columns){if(!(col in data)){throw new Error(`Column '${ col }' not found`)}}}function coordEach(geojson,callback,excludeWrapCoord){if(geojson===null){return}var j;var k;var l;var geometry;var stopG;var coords;var geometryMaybeCollection;var wrapShrink=0;var coordIndex=0;var isGeometryCollection;var type=geojson.type;var isFeatureCollection=type==='FeatureCollection';var isFeature=type==='Feature';var stop=isFeatureCollection?geojson.features.length:1;for(var featureIndex=0;featureIndex<stop;featureIndex+=1){geometryMaybeCollection=(isFeatureCollection?geojson.features[featureIndex].geometry:(isFeature?geojson.geometry:geojson));isGeometryCollection=(geometryMaybeCollection)?geometryMaybeCollection.type==='GeometryCollection':false;stopG=isGeometryCollection?geometryMaybeCollection.geometries.length:1;for(var geomIndex=0;geomIndex<stopG;geomIndex+=1){var multiFeatureIndex=0;var geometryIndex=0;geometry=isGeometryCollection?geometryMaybeCollection.geometries[geomIndex]:geometryMaybeCollection;if(geometry===null){continue}coords=geometry.coordinates;var geomType=geometry.type;wrapShrink=(excludeWrapCoord&&(geomType==='Polygon'||geomType==='MultiPolygon'))?1:0;switch(geomType){case null:break;case 'Point':if(callback(coords,coordIndex,featureIndex,multiFeatureIndex,geometryIndex)===false){return false}coordIndex+=1;multiFeatureIndex+=1;break;case 'LineString':case 'MultiPoint':for(j=0;j<coords.length;j+=1){if(callback(coords[j],coordIndex,featureIndex,multiFeatureIndex,geometryIndex)===false){return false}coordIndex+=1;if(geomType==='MultiPoint'){multiFeatureIndex+=1}}if(geomType==='LineString'){multiFeatureIndex+=1}break;case 'Polygon':case 'MultiLineString':for(j=0;j<coords.length;j+=1){for(k=0;k<coords[j].length-wrapShrink;k+=1){if(callback(coords[j][k],coordIndex,featureIndex,multiFeatureIndex,geometryIndex)===false){return false}coordIndex+=1}if(geomType==='MultiLineString'){multiFeatureIndex+=1}if(geomType==='Polygon'){geometryIndex+=1}}if(geomType==='Polygon'){multiFeatureIndex+=1}break;case 'MultiPolygon':for(j=0;j<coords.length;j+=1){geometryIndex=0;for(k=0;k<coords[j].length;k+=1){for(l=0;l<coords[j][k].length-wrapShrink;l+=1){if(callback(coords[j][k][l],coordIndex,featureIndex,multiFeatureIndex,geometryIndex)===false){return false}coordIndex+=1}geometryIndex+=1}multiFeatureIndex+=1}break;case 'GeometryCollection':for(j=0;j<geometry.geometries.length;j+=1){if(coordEach(geometry.geometries[j],callback,excludeWrapCoord)===false){return false}}break;default:throw new Error('Unknown Geometry Type')}}}}function transformGeometries(geometries,transformFunc){const geometriesClone=JSON.parse(JSON.stringify(geometries));if(geometriesClone.constructor===Array){for(let i=0;i<geometriesClone.length;i+=1){transformGeometryInplace(geometriesClone[i],transformFunc)}}if(geometriesClone.constructor===Object){for(const key in geometriesClone){transformGeometryInplace(geometriesClone[key],transformFunc)}}return geometriesClone}function transformGeometryInplace(geometry,transformFunc){coordEach(geometry,coord=>{const transformedPosition=transformFunc(coord);coord[0]=transformedPosition[0];coord[1]=transformedPosition[1]})}function reproject(data,transformation){if(!('$geometry'in data)){warn('No geometry column found. Skipping reproject-transformation.');return data}const transformedGeometries=transformGeometries(data.$geometry,transformation);data.$geometry=transformedGeometries;return data}function transform(data,transformFunction){if(transformFunction.constructor!==Function){throw new Error(`Invalid 'transform' transformation: must be a Function`)}transformFunction(data)}function cumsum(data,cumsumInstructions,options={asInterval:false}){const asInterval=options.asInterval;const length=getDataLength(data);const newColumns={};for(const newColName in cumsumInstructions){checkRegularColumnName(newColName);const oldColName=cumsumInstructions[newColName];if(getColumnType(data[oldColName])!=='quantitative'){throw new Error('cumsum columns can only be of type \'quantitative\'')}let previousSum=0;let currentSum=0;newColumns[newColName]=[];for(let i=0;i<length;i+=1){const value=data[oldColName][i];if(!isInvalid(value)){currentSum+=value}if(asInterval){newColumns[newColName].push([previousSum,currentSum])}else{newColumns[newColName].push(currentSum)}previousSum=currentSum}}Object.assign(data,newColumns)}function rowCumsum(data,_cumsumInstructions,options={asInterval:false}){const asInterval=options.asInterval;const cumsumInstructions=parseCumsumInstructions(_cumsumInstructions);validateColumns(data,cumsumInstructions);const rowCumsumColumns={};let previousColumnName;for(const[newName,oldName]of cumsumInstructions){checkRegularColumnName(newName);const oldColumn=data[oldName];if(previousColumnName===undefined){if(asInterval){rowCumsumColumns[newName]=oldColumn.map(value=>[0,value])}else{rowCumsumColumns[newName]=oldColumn}}else{const previousColumn=rowCumsumColumns[previousColumnName];let newColumn;if(asInterval){newColumn=oldColumn.map((value,i)=>{const previousValue=previousColumn[i][1];const newValue=previousValue+value;return[previousValue,newValue]})}else{newColumn=oldColumn.map((value,i)=>value+previousColumn[i])}rowCumsumColumns[newName]=newColumn}previousColumnName=newName}Object.assign(data,rowCumsumColumns)}const invalidInstructionsError=new Error('Invalid rowCumsum instrutions');function parseCumsumInstructions(cumsumInstructions){if(cumsumInstructions&&cumsumInstructions.constructor===Array){const parsedInstructions=[];for(const instruction of cumsumInstructions){validateInstruction(instruction);if(instruction.constructor===String){parsedInstructions.push([instruction,instruction])}if(instruction.constructor===Object){const newName=Object.keys(instruction)[0];const oldName=instruction[newName];parsedInstructions.push([newName,oldName])}}return parsedInstructions}throw invalidInstructionsError}function validateInstruction(instruction){if(instruction.constructor===String){return}if(instruction.constructor===Object){if(Object.keys(instruction).length===1){return}}throw invalidInstructionsError}function validateColumns(data,stackInstructions){for(const[,oldName]of stackInstructions){const column=data[oldName];if(!column){throw new Error(`Column '${ oldName }' does not exist`)}const columnType=getColumnType(column);if(columnType!=='quantitative'){throw new Error('rowCumsum columns can only be of type \'quantitative\'')}}}const transformations={filter,select:produce(select),arrange:produce(arrange),rename:produce(rename),mutate:produce(mutate),transmute:produce(transmute),summarise,mutarise,groupBy,bin,dropNA,reproject:produce(reproject),transform:produce(transform),cumsum:produce(cumsum),rowCumsum:produce(rowCumsum)};const methods$1={arrange(sortInstructions){const data=transformations.arrange(this._data,sortInstructions);return new DataContainer(data,{validate:false})},bin(binInstructions){const data=transformations.bin(this._data,binInstructions);return new DataContainer(data,{validate:false})},cumsum(cumsumInstructions,options){const data=transformations.cumsum(this._data,cumsumInstructions,options);return new DataContainer(data,{validate:false})},dropNA(dropInstructions){const data=transformations.dropNA(this._data,dropInstructions);return new DataContainer(data,{validate:false})},filter(filterFunction){const data=transformations.filter(this._data,filterFunction);return new DataContainer(data,{validate:false})},groupBy(groupByInstructions){const data=transformations.groupBy(this._data,groupByInstructions);return new DataContainer(data,{validate:false})},mutarise(mutariseInstructions){const data=transformations.mutarise(this._data,mutariseInstructions);return new DataContainer(data,{validate:false})},mutarize(mutariseInstructions){const data=transformations.mutarise(this._data,mutariseInstructions);return new DataContainer(data,{validate:false})},mutate(mutateInstructions){const data=transformations.mutate(this._data,mutateInstructions);return new DataContainer(data,{validate:false})},transmute(transmuteInstructions){const data=transformations.transmute(this._data,transmuteInstructions);return new DataContainer(data,{validate:false})},rename(renameInstructions){const data=transformations.rename(this._data,renameInstructions);return new DataContainer(data,{validate:false})},reproject(reprojectInstructions){const data=transformations.reproject(this._data,reprojectInstructions);return new DataContainer(data,{validate:false})},rowCumsum(cumsumInstructions,options){const data=transformations.rowCumsum(this._data,cumsumInstructions,options);return new DataContainer(data,{validate:false})},select(selection){const data=transformations.select(this._data,selection);return new DataContainer(data,{validate:false})},summarise(summariseInstructions){const data=transformations.summarise(this._data,summariseInstructions);return new DataContainer(data,{validate:false})},summarize(summariseInstructions){const data=transformations.summarise(this._data,summariseInstructions);return new DataContainer(data,{validate:false})},transform(transformFunction){const data=transformations.transform(this._data,transformFunction);return new DataContainer(data,{validate:false})}};function transformationsMixin(targetClass){Object.assign(targetClass.prototype,methods$1)}function ensureValidRow(row,self){for(const columnName in row){if(!(columnName in self._data)){throw new Error(`Column '${ columnName }' not found`)}}for(const columnName in self._data){if(columnName==='$key'){if(columnName in row){throw new Error('Cannot set \'$key\' column')}}else{if(!(columnName in row)){throw new Error(`Missing column '${ columnName }'`)}const value=row[columnName];ensureValueIsRightForColumn(value,columnName,self)}}}function ensureValidRowUpdate(row,self){for(const columnName in row){if(!(columnName in self._data)){throw new Error(`Column '${ columnName }' not found`)}const value=row[columnName];ensureValueIsRightForColumn(value,columnName,self)}}function ensureRowExists(key,self){if(isUndefined(self._keyToRowNumber[key])){throw new Error(`Key '${ key }' not found`)}}function ensureValueIsRightForColumn(value,columnName,self){if(!isInvalid(value)){const columnType=getColumnType(self._data[columnName]);ensureValidDataType(value);const valueType=getDataType(value);if(columnType!==valueType){throw new Error(`Column '${ columnName }' is of type '${ columnType }'. Received value of type '${ valueType }'`)}}}function isValidColumn(column,columnName){const columnType=getColumnType(column);if(columnType===undefined){return false}if(!columnNameMatchesType(columnName,columnType)){return false}if(!allValidValuesHaveTheSameType(column,columnType)){return false}return true}function ensureValidColumn(column,columnName){const{nValidValues}=findFirstValidValue(column);if(nValidValues===0){throw new Error(`Invalid column '${ columnName }'. Column contains only invalid values.`)}const columnType=getColumnType(column);if(columnType===undefined){throw new Error(`Column '${ columnName }' contains data of unknown type`)}ensureColumnNameMatchesType(columnType);ensureAllValidValuesHaveTheSameType(column,columnType,columnName)}function columnNameMatchesType(columnName,columnType){if(columnName==='$geometry'&&columnType!=='geometry'){return false}if(columnName!=='$geometry'&&columnType==='geometry'){return false}return true}function ensureColumnNameMatchesType(columnName,columnType){if(columnName==='$geometry'&&columnType!=='geometry'){throw new Error(`Column '$geometry' can only contain data of type 'geometry', received '${ columnType }'`)}if(columnName!=='$geometry'&&columnType==='geometry'){throw new Error(`Only the '$geometry' column can contain data of type 'geometry'`)}}function allValidValuesHaveTheSameType(column,columnType){for(let i=0;i<column.length;i+=1){const value=column[i];if(isInvalid(value)){continue}const valueType=getDataType(value);if(valueType!==columnType){return false}}return true}function ensureAllValidValuesHaveTheSameType(column,columnType,columnName){if(!allValidValuesHaveTheSameType(column,columnType)){throw new Error(`Column '${ columnName }' mixes types`)}}function columnExists(columnName,self){return columnName in self._data}function ensureColumnExists(columnName,self){if(!columnExists(columnName,self)){throw new Error(`Invalid column name: '${ columnName }'`)}}const methods$2={addRow(row){ensureValidRow(row,this);const self=this;this._data=produce(this._data,draft=>{for(const columnName in row){const value=row[columnName];draft[columnName].push(value);self._updateDomainIfNecessary(columnName,value)}});const rowNumber=getDataLength(this._data)-1;const keyDomain=this.domain('$key');keyDomain[1]+=1;const key=keyDomain[1];this._data=produce(this._data,draft=>{draft.$key.push(key)});this._keyToRowNumber[key]=rowNumber},updateRow(key,row){if(row.constructor===Function){const result=row(this.row(key));if(!(result&&result.constructor===Object)){throw new Error('updateRow function must return Object')}this.updateRow(key,result)}ensureRowExists(key,this);ensureValidRowUpdate(row,this);const self=this;const rowNumber=this._keyToRowNumber[key];this._data=produce(this._data,draft=>{for(const columnName in row){throwErrorIfColumnIsKey(columnName);const value=row[columnName];draft[columnName][rowNumber]=value;self._resetDomainIfNecessary(columnName)}})},deleteRow(key){ensureRowExists(key,this);const self=this;const rowNumber=this._keyToRowNumber[key];delete this._keyToRowNumber[key];this._data=produce(this._data,draft=>{for(const columnName in draft){draft[columnName].splice(rowNumber,1);self._resetDomainIfNecessary(columnName)}})},addColumn(columnName,column){this._validateNewColumn(columnName,column);this._data=produce(this._data,draft=>{draft[columnName]=column})},replaceColumn(columnName,column){this.deleteColumn(columnName);this.addColumn(columnName,column)},deleteColumn(columnName){ensureColumnExists(columnName,this);throwErrorIfColumnIsKey(columnName);if(Object.keys(this._data).length===2){throw new Error('Cannot delete last column')}this._data=produce(this._data,draft=>{delete draft[columnName]})},_updateDomainIfNecessary(columnName,value){const type=getDataType(value);if(columnName in this._domains){this._domains[columnName]=updateDomain(this._domains[columnName],value,type)}},_resetDomainIfNecessary(columnName){if(columnName in this._domains){delete this._domains[columnName]}},_validateNewColumn(columnName,column){checkRegularColumnName(columnName);if(columnName in this._data){throw new Error(`Column '${ columnName }' already exists`)}const dataLength=getDataLength(this._data);if(dataLength!==column.length){throw new Error('Column must be of same length as rest of data')}ensureValidColumn(column)}};function modifyingRowsAndColumnsMixin(targetClass){Object.assign(targetClass.prototype,methods$2)}function throwErrorIfColumnIsKey(columnName){if(columnName==='$key'){throw new Error('Cannot modify key column')}}function getJoinColumns(left,right,by){const leftData=left.data();const rightData=right.data();if(isUndefined(by)){const leftDataLength=getDataLength(leftData);const joinColumns={};for(const columnName in rightData){if(columnName!=='$key'){const rightColumn=rightData[columnName];joinColumns[columnName]=rightColumn.slice(0,leftDataLength)}}return joinColumns}if(isDefined(by)){const joinColumns=initJoinColumns(rightData,by[1]);const rightRowsByKey=generateRightRowsByKey(rightData,by[1]);const leftByColumn=leftData[by[0]];for(let i=0;i<leftByColumn.length;i+=1){const leftKey=leftByColumn[i];const row=rightRowsByKey[leftKey];for(const columnName in row){joinColumns[columnName].push(row[columnName])}}return joinColumns}}function initJoinColumns(right,byColumnName){const joinColumns={};for(const columnName in right){if(columnName!=='$key'&&columnName!==byColumnName){joinColumns[columnName]=[]}}return joinColumns}function generateRightRowsByKey(right,byColumnName){const rightRowsByKey={};const byColumn=right[byColumnName];for(let i=0;i<byColumn.length;i+=1){const key=byColumn[i];const row={};for(const columnName in right){if(columnName!=='$key'&&columnName!==byColumnName){row[columnName]=right[columnName][i]}}rightRowsByKey[key]=row}return rightRowsByKey}function validateJoin(left,right,by){const leftData=left.data();const rightData=getRightData(right);if(isUndefined(by)){const leftLength=getDataLength(leftData);const rightLength=getDataLength(rightData);if(rightLength<leftLength){throw new Error('Without \'by\', the right DataContainer must be the same length as or longer than left DataContainer')}}if(isDefined(by)){validateByColumnsExist(leftData,rightData,by);ensureColumnsAreCompatible(leftData,rightData,by);ensureNoDuplicateColumnNames(leftData,rightData,by)}}function getRightData(right){if(!(right instanceof DataContainer)){throw new Error('It is only possible to join another DataContainer')}return right.data()}function validateByColumnsExist(left,right,by){if(!(by.constructor===Array&&by.length===2&&by.every(c=>c.constructor===String))){throw new Error('Invalid format of \'by\'. Must be Array of two column names.')}const[leftColumnName,rightColumnName]=by;if(!(leftColumnName in left)){throw new Error(`Column '${ leftColumnName }' not found`)}if(!(rightColumnName in right)){throw new Error(`Column '${ rightColumnName }' not found`)}}function ensureColumnsAreCompatible(left,right,by){const[leftColumnName,rightColumnName]=by;const leftColumn=left[leftColumnName];const rightColumn=right[rightColumnName];const leftType=getColumnType(leftColumn);const rightType=getColumnType(rightColumn);if(leftType!==rightType){throw new Error('\'by\' columns must be of the same type')}ensureRightByColumnIsUnique(right[rightColumnName]);ensureLeftColumnIsSubsetOfRightColumn(leftColumn,rightColumn)}function ensureRightByColumnIsUnique(column){if(column.length!==new Set(column).size){throw new Error('Right \'by\' column must contain only unique values')}}function ensureLeftColumnIsSubsetOfRightColumn(leftColumn,rightColumn){const rightSet=new Set(rightColumn);for(let i=0;i<leftColumn.length;i+=1){const leftKey=leftColumn[i];if(!rightSet.has(leftKey)){throw new Error('Left \'by\' column must be subset of right column')}}}function ensureNoDuplicateColumnNames(left,right,by){const rightColumnName=by[1];for(const columnName in right){if(columnName!=='$key'&&columnName in left){if(columnName!==rightColumnName){throw new Error(`Duplicate column name: '${ columnName }'`)}}}}class DataContainer{constructor(data,options={validate:true}){this._data={};this._keyToRowNumber={};this._domains={};if(isColumnOriented(data)){this._setColumnData(data,options);return}if(isRowOriented(data)){this._setRowData(data,options);return}if(isGeoJSON(data)){this._setGeoJSON(data,options);return}if(data instanceof Group){this._setGroup(data,options);return}throw invalidDataError}data(){return this._data}row(key){const rowNumber=this._keyToRowNumber[key];return this._row(rowNumber)}prevRow(key){const rowNumber=this._keyToRowNumber[key];const previousRowNumber=rowNumber-1;return this._row(previousRowNumber)}nextRow(key){const rowNumber=this._keyToRowNumber[key];const nextRowNumber=rowNumber+1;return this._row(nextRowNumber)}rows(){const rows=[];const length=getDataLength(this._data);for(let i=0;i<length;i+=1){rows.push(this._row(i))}return rows}column(columnName){ensureColumnExists(columnName,this);return this._data[columnName]}map(columnName,mapFunction){return this.column(columnName).map(mapFunction)}domain(columnName){if(columnName in this._domains){return this._domains[columnName]}const column=this.column(columnName);const domain=calculateDomain(column,columnName);this._domains[columnName]=domain;return domain}type(columnName){const column=this.column(columnName);return getColumnType(column)}columnNames(){return Object.keys(this._data)}hasColumn(columnName){return columnExists(columnName,this)}columnIsValid(columnName){const column=this.column(columnName);return isValidColumn(column,columnName)}validateColumn(columnName){const column=this.column(columnName);ensureValidColumn(column,columnName)}validateAllColumns(){for(const columnName in this._data){this.validateColumn(columnName)}}join(dataContainer,{by=undefined}={}){validateJoin(this,dataContainer,by);const joinColumns=getJoinColumns(this,dataContainer,by);for(const columnName in joinColumns){this.addColumn(columnName,joinColumns[columnName])}}_row(rowNumber){const length=getDataLength(this._data);if(rowNumber<0||rowNumber>=length){return undefined}const row={};for(const columnName in this._data){const value=this._data[columnName][rowNumber];row[columnName]=value}return row}}dataLoadingMixin(DataContainer);transformationsMixin(DataContainer);modifyingRowsAndColumnsMixin(DataContainer);const invalidDataError=new Error('Data passed to DataContainer is of unknown format');return DataContainer})));